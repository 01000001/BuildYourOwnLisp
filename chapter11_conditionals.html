<h2>Conditionals</h2>
<p>Okay so we&#39;ve come pretty far now. This chapter you should be able to do on your own. It basically consists of adding some builtin functions to perform conditional evaluation. Also while we&#39;re at it we&#39;re going to add some functions for doing equality, greater than, less than etc.</p>
<p>The only tricky part may consists of defining an <code>if</code> function and equality testing between <code>lval</code>s but even that should be okay.</p>
<p>For simplicity&#39;s sake we&#39;re going to re-use our number data type to do truth testing. We&#39;ll make a rule to say that any number that isn&#39;t <code>0</code> evaluates to true in an <code>if</code> statement while <code>0</code> always evaluates to false.</p>
<h3>Ordering</h3>
<p>Our ordering functions are a little like a simplified version of our arithmetic functions. They&#39;ll only work on numbers, and we only want them to work on two arguments so we already have some initial error conditions.</p>
<p>Once these conditions are held the maths is simple, we want to return an integer either <code>0</code> or <code>1</code> depending on the equality comparison between the two lisp values. We can use C&#39;s operators to do this. As before because these functions are simple we&#39;ll use a single function can can choose to perform any of the comparisons.</p>
<pre><code class="lang-c">lval* builtin_ord(lenv* e, lval* a, char* op) {
  LASSERT(a, (a-&gt;count == 2               ), &quot;Function &#39;%s&#39; passed too many arguments. Got %i, Expected %i.&quot;, op, a-&gt;count, 2);
  LASSERT(a, (a-&gt;cell[0]-&gt;type == LVAL_NUM), &quot;Function &#39;%s&#39; passed incorrect type. Got %s, Expected %s.&quot;, op, ltype_name(a-&gt;cell[0]-&gt;type), ltype_name(LVAL_NUM));
  LASSERT(a, (a-&gt;cell[1]-&gt;type == LVAL_NUM), &quot;Function &#39;%s&#39; passed incorrect type. Got %s, Expected %s.&quot;, op, ltype_name(a-&gt;cell[0]-&gt;type), ltype_name(LVAL_NUM));
  int r;
  if (strcmp(op, &quot;&gt;&quot;)  == 0) { r = (a-&gt;cell[0]-&gt;num &gt;  a-&gt;cell[1]-&gt;num); }
  if (strcmp(op, &quot;&lt;&quot;)  == 0) { r = (a-&gt;cell[0]-&gt;num &lt;  a-&gt;cell[1]-&gt;num); }
  if (strcmp(op, &quot;&gt;=&quot;) == 0) { r = (a-&gt;cell[0]-&gt;num &gt;= a-&gt;cell[1]-&gt;num); }
  if (strcmp(op, &quot;&lt;=&quot;) == 0) { r = (a-&gt;cell[0]-&gt;num &lt;= a-&gt;cell[1]-&gt;num); }
  lval_del(a);
  return lval_num(r);
}

lval* builtin_gt(lenv* e, lval* a) { return builtin_ord(e, a, &quot;&gt;&quot;);  }
lval* builtin_lt(lenv* e, lval* a) { return builtin_ord(e, a, &quot;&lt;&quot;);  }
lval* builtin_ge(lenv* e, lval* a) { return builtin_ord(e, a, &quot;&gt;=&quot;); }
lval* builtin_le(lenv* e, lval* a) { return builtin_ord(e, a, &quot;&lt;=&quot;); }</code></pre>
<p>First we check the error conditions, then we compare the numbers in each of the arguments to get some result. Finally we return this result as a number value.</p>
<h3>Equality</h3>
<p>Equality is a little more complicated than ordering because we&#39;d wish for it to work on other types of data. For example it would be nice if as well as numbers we could compare symbols, or even functions!</p>
<pre><code class="lang-c">int lval_eq(lval* x, lval* y) {

  /* Different Types are always unequal */
  if (x-&gt;type != y-&gt;type) { return 0; }

  /* Compare Based upon type */
  switch (x-&gt;type) {
    /* Compare Number Value */
    case LVAL_NUM: return (x-&gt;num == y-&gt;num);

    /* Compare String Values */
    case LVAL_ERR: return (strcmp(x-&gt;err, y-&gt;err) == 0);
    case LVAL_SYM: return (strcmp(x-&gt;sym, y-&gt;sym) == 0);

    /* If Builtin compare functions, otherwise compare formals and body */
    case LVAL_FUN: if (x-&gt;builtin) { return x-&gt;builtin == y-&gt;builtin; } else { return lval_eq(x-&gt;formals, y-&gt;formals) &amp;&amp; lval_eq(x-&gt;body, y-&gt;body); }

    /* If list compare every individual element */
    case LVAL_QEXPR:
    case LVAL_SEXPR:
      if (x-&gt;count != y-&gt;count) { return 0; }
      for (int i = 0; i &lt; x-&gt;count; i++) {
        /* If any element not equal then whole list not equal */
        if (!lval_eq(x-&gt;cell[0], y-&gt;cell[0])) { return 0; }
      }
      /* Otherwise lists must be equal */
      return 1;
    break;
  }
  return 0;
}</code></pre>
<p>TODO: Talk about this function</p>
<p>With this our builtin functions become very simple. We just ensure there are two arguments and compare them.</p>
<pre><code class="lang-c">lval* builtin_cmp(lenv* e, lval* a, char* op) {
  LASSERT(a, (a-&gt;count == 2), &quot;Function &#39;%s&#39; passed too many arguments. Got %i, Expected %i.&quot;, op, a-&gt;count, 2);
  int r;
  if (strcmp(op, &quot;==&quot;) == 0) { r =  lval_eq(a-&gt;cell[0], a-&gt;cell[1]); }
  if (strcmp(op, &quot;!=&quot;) == 0) { r = !lval_eq(a-&gt;cell[0], a-&gt;cell[1]); }
  lval_del(a);
  return lval_num(r);
}

lval* builtin_eq(lenv* e, lval* a) { return builtin_cmp(e, a, &quot;==&quot;); }
lval* builtin_ne(lenv* e, lval* a) { return builtin_cmp(e, a, &quot;!=&quot;); }</code></pre>
<h3>An If Statement</h3>
<p>The final part of comparison is to create an <code>if</code> statement. This should perform one thing based upon if a condition is true, and another if a condition is false.</p>
<p>To do this we can use a technique similar to how we create our functions. We can take as input a conditional value, and two Q-Expressions representing the two possible computations, one for when the condition is true, and another for when it false.</p>
<p>We then simply check if the conditional value is <code>1</code> or <code>0</code> and evaluate one or the other of the Q-expressions. The one not evaluated can simply be deleted.</p>
<pre><code class="lang-c">lval* builtin_if(lenv* e, lval* a) {
  LASSERT(a, (a-&gt;count == 3                 ), &quot;Function &#39;if&#39; passed too many arguments. Got %i, Expected %i.&quot;, a-&gt;count, 3);
  LASSERT(a, (a-&gt;cell[0]-&gt;type == LVAL_NUM  ), &quot;Function &#39;if&#39; passed incorrect type. Got %s, Expected %s.&quot;, ltype_name(a-&gt;cell[0]-&gt;type), ltype_name(LVAL_NUM));
  LASSERT(a, (a-&gt;cell[1]-&gt;type == LVAL_QEXPR), &quot;Function &#39;if&#39; passed incorrect type. Got %s, Expected %s.&quot;, ltype_name(a-&gt;cell[1]-&gt;type), ltype_name(LVAL_QEXPR));
  LASSERT(a, (a-&gt;cell[2]-&gt;type == LVAL_QEXPR), &quot;Function &#39;if&#39; passed incorrect type. Got %s, Expected %s.&quot;, ltype_name(a-&gt;cell[2]-&gt;type), ltype_name(LVAL_QEXPR));

  /* Mark Both Expressions as evaluatable */
  lval* x;
  a-&gt;cell[1]-&gt;type = LVAL_SEXPR;
  a-&gt;cell[2]-&gt;type = LVAL_SEXPR;

  if (a-&gt;cell[0]-&gt;num) {
    /* If condition is true evaluate first expression */
    x = lval_eval(e, lval_pop(a, 1));
  } else {
    /* Otherwise evaluate second expression */
    x = lval_eval(e, lval_pop(a, 2));
  }

  /* Delete argument list and return */
  lval_del(a);
  return x;
}</code></pre>
<p>TODO: Talk about this.</p>
<p>Finally we can register all of these new functions as builtins and we are done.</p>
<pre><code class="lang-c">  /* Comparison Functions */
  lenv_add_builtin(e, &quot;if&quot;,   builtin_if);
  lenv_add_builtin(e, &quot;==&quot;,   builtin_eq); lenv_add_builtin(e, &quot;!=&quot;,   builtin_ne);
  lenv_add_builtin(e, &quot;&gt;&quot;,    builtin_gt); lenv_add_builtin(e, &quot;&lt;&quot;,    builtin_lt);
  lenv_add_builtin(e, &quot;&gt;=&quot;,   builtin_ge); lenv_add_builtin(e, &quot;&lt;=&quot;,   builtin_le);</code></pre>
<h3>Recursive Functions</h3>
<p>Having conditionals means we can effective implement recursive functions. These are essentially a form of looping used commonly in functional languages such as our Lisp. For example say we want a function <code>len</code> that can tell us the number of items in a list we can implement it like this.</p>
<pre><code>(fun {len l} {
  if (== l {})
    {0}
    {+ 1 (len (tail l))}
})</code></pre>
<p>It works like this. If we encounter the empty list we just return <code>0</code>. Otherwise we return <code>1</code>, plus the length of the <code>tail</code> of the list. Think for a while why that works. It repeatedly uses the <code>len</code> function until it reaches the empty list. At this point it returns <code>0</code> and adds all the other partial results together.</p>
<p>There is a pleasant symmetry to this sort of recursive function. First we do something for the empty list (this is often called <em>the base case</em>). Then if we get something bigger, we take off a chunk (usually the head of the list) and do something to it, before combining it with the rest of the thing to which the function has been already applied. </p>
<p>Here is another function for reversing a list.</p>
<pre><code>(fun {reverse l} {
  if (== l {})
    {{}}
    {join (reverse (tail l)) (head l)}
})</code></pre>
<p>Again it checks for the empty list, but this time returns the empty list back. This makes sense - the reverse of the empty list is just the empty list. If it gets something bigger than the empty list it reverses the tail - and sticks this in front of the head. In fact we can build a whole bunch of functions like this, and doing so is good practice, because it is going to be the primary way to achieve looping in our language.</p>
<p>Once we do start making all of these functions it might become labourious to keep typing them into the prompt. Instead we&#39;d wish to write them all down in a file and have the ability to load them all at once. This is what we&#39;ll be covering in the next chapter!</p>
<h3>Tutorial Code</h3>
<p><a href="">example9.c</a></p>
<h3>Bonus Marks</h3>
<ul>
<li>Implement a recursive function that given a list and an integer finds the <code>nth</code> item of that list.</li>
<li>Implement a recursive function that checks if a given element is a member of a list.</li>
<li>Implement a recursive function that gives the last element in a list.</li>
<li>Implement logical operator functions such as <code>or</code>, <code>and</code> and <code>not</code>.</li>
<li>In C add real <code>true</code> and <code>false</code> values to the language with a separate boolean type.</li>
</ul>