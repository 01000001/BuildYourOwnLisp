<h2>Chapter 3 - An Interactive Prompt</h2>


<h3>Read, Evaluate, Print</h3>

<p>The first step we are going to make is to build an interactive prompt. This is a program that prompts the user for some input, and when supplied with it, replies back with some message. Using this will be the easiest way to test our programming language and see how it acts. This system is called a <em>REPL</em> and stands for <em>read</em>, <em>evaluate</em>, <em>print</em> <em>loop</em>. It is a common way of interacting with a programming language. You may have used before in languages such as <em>Python</em>.</p>

<p>Before building a full <em>REPL</em> we&#39;ll start with something simpler. We are going to make a system that prompts the user, and echos any input straight back. If we make this, later we can extend it to parse the user input and evaluate it, as if it were an actual Lisp program.</p>

<p>For the basic setup in C we want to write a loop which repeatedly prompts the user for input. We can declare a statically sized input buffer and use the <code>fgets</code> function to read into it. This function will read any input from the user up until a newline. It wont read more than the size of the buffer passed to it. We can then print this input back to the user using <code>fprintf</code>. The user input from <code>fgets</code> will include the newline character so we don&#39;t need to add this to the end of <code>fprintf</code> when we echo it back.</p>

<p>The following C code contains <em>comments</em>. These are sections of the code between <code>/*</code> <code>*/</code> symbols, which are not evaluated by the compiler. They are used to inform the person reading what is going on, and I'm going to be using a lot of them. Take a read over this code and see if you can get an intuition as to how it works.</p>

<pre><code class="lang-c">#include &lt;stdio.h&gt;

/* Declare a static buffer for user input of size 2048 */
static char input[2048];

int main(int argc, char** argv) {

  /* Print Version and Exit Information */
  fputs(&quot;Lispy Version 0.0.0.0.1\n&quot;, stdout);
  fputs(&quot;Press Ctrl+c to Exit\n\n&quot;, stdout);

  /* In a never ending loop */
  while (1) {

    /* Output our prompt */
    fputs(&quot;lispy&gt; &quot;, stdout);

    /* Read a line of user input of maximum size 2047 */
    fgets(input, 2047, stdin);

    /* Echo input back to user */
    fprintf(stdout, &quot;No you&#39;re a %s&quot;, input);
  }

  return 0;
}</code></pre>

<p>There are some new concepts here so lets go over them briefly.<p>

<p>The line of code <code>static char input[2048];</code> declares a global array of 2048 characters. This is a reserved block of data we can acccess anywhere from our program. In it we are going to store the user input which is typed into the console. The <code>static</code> keyword is what makes it global and the <code>[2048]</code> section is what declares the size. <code>char</code> is the type, meaning <em>character</em>. In C arrays of <code>char</code> are the same as strings, so we are able to use this variable in all of our string functions.</p>

<p>We write an infinite loop using <code>while (1)</code>. Because the number <code>1</code> always evaluates to true this means the commands inside our loop (denoted by curly braces </code>{}</code>) runs forever.</p>

<p>The <code>fputs</code> and <code>fgets</code> are functions for putting and getting strings from the console. <code>fputs</code> is similar to the <code>puts</code> function we saw in the previous chapter except that it takes as output location to write to. This is where <code>stdout</code> and <code>stdin</code> come in. In C these are the names for the console input and output, and we supply them to these variations of the functions prefixed by <code>f</code>.</p>

<p>Finally there is <code>fprintf</code>, which is a way of printing messages consisting of several elements. It matches arguments to patterns in the input string. For example in our case we can see the <code>%s</code> pattern in the input string. This means that it will be replaced by whatever argument is passed in next, interprited as a string. In our case the <code>input</code> variable. For more information on these different patterns please see the <a href="http://en.cppreference.com/w/c/io/fprintf">reference documentation</a></p>

<p>You can compile this with the same command as was used in the previous chapter. After compiling this you should try to run it. You can use <code>Ctrl+c</code> to quit the program when you are done. If everything is correct your interaction should resembles the following.</p>

<pre><code>$ chapter3
Lispy Version 0.0.0.0.1
Press Ctrl+c to Exit

lispy&gt; hello
No You&#39;re a hello
lispy&gt; my name is Dan
No You&#39;re a my name is Dan
lispy&gt; Stop being so rude!
No You&#39;re a Stop being so rude!
lispy&gt;</code></pre>

<p>If your program does not compile examine the output from the compiler. Does it mention a line number? Can you see anything wrong on this line number? Try to fix any error mentioned by the compiler.</p>

<h3>Editing input</h3>

<p>If you're working on Linux or Mac you'll notice some weird behaviour when you use the arrow keys to attempt to edit your input.</p>

<pre><code>$ ./chapter3
  Lispy Version 0.0.0.0.3
  Press Ctrl+c to Exit
  
  lispy> + 1 2^[[D^[[C           
</code></pre>

<p>Using the arrow keys is creating these weird characters <code>^[[D</code> or <code>^[[C</code>, rather than moving the cursor around in the input. What we really want is to be able to move around in the line, deleting and editing the input in case we make a mistake.</p>

<p>On windows this behaviour is built in, but on Linux and Mac we have to use a library called <code>editline</code> to do it. If we replace our calls to <code>fputs</code> and <code>fgets</code> with calls to this library we can get the correct behaviour.</p>

<p>This library is called <code>editline</code> and it provides two functions we are going to use called <code>readline</code> and <code>add_history</code>. This first function, <code>readline</code> is used to read input from some prompt while allowing for editing of that input. The second function <code>add_history</code> lets us record the history of inputs so that they can be retrived with the up and down arrows.</p>

<p>When we use this library it looks like the following.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;editline/readline.h&gt;
#include &lt;editline/history.h&gt;

static char input[2048];

int main(int argc, char** argv) {
   
  /* Print Version and Exit Information */
  fputs("Lispy Version 0.0.0.0.1\n", stdout);
  fputs("Press Ctrl+c to Exit\n\n", stdout);
   
  /* In a never ending loop */
  while (1) {
    
    /* Output our prompt an get input */
    char* input = readline("lispy> ");
    
    /* Add input to history */
    add_history(input);
    
    /* Echo input back to user */    
    fprintf(stdout, "No you're a %s\n", input);

    /* Free retrived input */
    free(input);
    
  }
  
  return 0;
}</code></pre>

<p>The first difference is that we have included a few new headers at the top of the file. Firstly we have added <code>#include &lt;stdlib.h&gt;</code>. This is because we need to use the function from there called <code>free</code>. Secondly we include the headers for the <code>editline</code> library. These are added as <code>#include &lt;editline/readline.h&gt;</code> and <code>#include &lt;editline/history.h&gt;</code>. These give us access to the previously mentioned <code>readline</code> and <code>add_history</code> functions.</p>

<p>Inside our finite loop there is a change to the process. Now instead of prompting and getting our input with <code>fgets</code> we get it in one go using <code>readline</code>. We then pass this to the <code>add_history</code> function to record it, and print it out as before using <code>fprintf</code>. Unlike <code>fgets</code>, the <code>readline</code> function strips the trailing newline character from the input, so we need to add this to our <code>fprintf</code> function. Finally we need to delete the input given to us by the <code>readline</code> function. This is because unlike <code>fgets</code> which writes to some existing memory, the <code>readline</code> function allocates new memory when it is called. Don't worry too much about this as we will cover it in depth later.</p>

<p>If you try to compile this right away its likely you'll get an error such as the following: <code>fatal error: editline/readline.h: No such file or directory #include <&lt;editline/readline.h&gt;</code>. This is because you first need to install the <code>editline</code> library.</p>

<p>On Ubuntu or similar Linux distributions this can be done using the following console command.</p>

<pre><code>sudo apt-get install libedit-dev</code></pre>

<p>TODO: How to install on mac</p>

<p>You will also need to change your command your are compiling your program with to include it there. This is done by adding the flag <code>-ledit</code> before the output flag.</p>

<pre><code>cc -std=c99 -Wall -Werror -Wno-unused -g chapter3.c -lm -ledit -o chapter3</code></pre>

<p>Hopefully now you can compile without issues and editing the line is possible<p>


<h3>The C Preprocessor</h3>

<p>The above situation is all well and good when developing on one platform, but what if I want to send my source code to a friend who uses a different operating system. Ideally I'd wish for my source code to be able to compile no matter where, or on what computer, it is being compiled. This is a universal problem in C and there is no easy or always correct solution.<p>

<p>Luckily C does provide a mechanism to help, called the C preprocessor.</p>

<p>The C preprocessor is a program that runs before the compiler. It has a number of purposes, and we've actually be using it already, without knowing. Any line the starts with a hash <code>#</code> character is a preprocessor line, and we've been using it to <em>include</em> header files, giving us access to functions from the standard library and others.</p>

<p>The preprocessor can also be used to detect which operating system the code is being compiled on, and to emit different code depending on it</p>

<p>The way we're going to use it is like this. If we are running Windows we're going to let the preprocessor emit code with some fake <code>readline</code> and <code>add_history</code> functions I've prepared, otherwise we are going to include the headers from <code>editline</code> and use these.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* If we are compiling on Windows include these functions */
#ifdef _WIN32

static char input[2048];

char* readline(char* prompt) {
  
  fputs("lispy> ", stdout);
  fgets(input, 2047, stdin);
    
  char* cpy = malloc(strlen(input)+1);
  strcpy(cpy, input);
  input[strlen(input)] = '\0';
  
  return input;
}

void add_history(char* unused) {}

/* Otherwise include the editline headers */
#else

#include &lt;editline/readline.h&gt;
#include &lt;editline/history.h&gt;

#endif

int main(int argc, char** argv) {
   
  fputs("Lispy Version 0.0.0.0.1\n", stdout);
  fputs("Press Ctrl+c to Exit\n\n", stdout);
   
  while (1) {
    
    /* In either case readline will be defined */
    char* input = readline("lispy> ");
    add_history(input);

    fprintf(stdout, "No you're a %s\n", input);
    free(input);
    
  }
  
  return 0;
}</code></pre>

<p>The <code>#ifdef</code> preprocessor function is like an <code>if</code> function that happens before the code is compiled. All the contents of the file up until the next <code>#else</code> are used if the condition is true. Otherwise all the contents from the <code>#else</code> to the final <code>#endif</code> are used instead.</p>

<p>Now our code should be able to be compiled on Windows, Linux or Mac!</p>

<h3>Tutorial Code</h3>

<p><a href="chapter3.c">chapter3.c</a></p>


<h3>Bonus Marks</h3>

<ul>
  <li>Can you work out what <code>\n</code> means in those C strings?</li>
  <li>Change the prompt from <code>lispy&gt;</code> to something of your choice.</li>
  <li>Add an extra message to the <em>Version</em> and <em>Exit</em> Information.</li>
  <li>Make the system echo something different back to the user.</li>
  <li>Find out what other patterns you can use in <code>fprintf</code>.</li>
  <li>What happens when you pass <code>fprintf</code> a variable that is not a string, such as <code>argc</code>?</li>
   <li>Can you find out what does the preprocessor command <code>#ifndef</code> does?</li>
   <li>Can you find out what does the preprocessor command <code>#define</code> does?</li>
   <li>If <code>_WIN32</code> is defined on windows, can you find our what is defined for Linux or Mac?</li>
</ul>
