<h2>A Basic Maths Grammar</h2>


<h3>Polish Notation</h3>

<p>To try out <code>mpc</code> we're going to implement a simple grammar that resembles a mathematical subset of our lisp. It's called <a href="http://en.wikipedia.org/wiki/Polish_notation">Polish Notation</a> and is like standard mathematical expressions except for the fact that the operator (such as the <code>+</code> symbol), comes before the operands (such as the number <code>5</code>. Some examples of this notation might be <code>+ 1 2 6</code> or <code>+ 6 (* 2 9)</code>.</p>

<p>A good way to get started is to first describe the grammar <em>textually</em> as we've been doing in the previous chapters. We can state something like this 'an <em>expression</em> is either a <em>number</em>, or, in parenthesis, an <em>operator</em> followed by one or more <em>expression</em>s'. We can break this down again and more formally.

<ul>
  <li>An <code>Expression</code> is a <code>Number</code> or <code>'('</code> and an <code>Operator</code> and one or more <code>Expression</code> and an <code>')'</code>.</li>
  <li>An Operator is <code>'+'</code> or <code>'-'</code> or <code>'*'</code> or <code>'/'</code>.</li>
  <li>A Number is an optional <code>-</code> and one or more characters between <code>0</code> and <code>9</code></li>
  <li>A Program is the start of input and an <code>Operator</code> and one or more <code>Expression</code> and the end of input.</li>
</ul>

<h3>Regular Expressions</h3>

<p>Most of the above we can write using our grammar as usual, but <em>Number</em> might pose some trouble. It contains a couple of constructs we've not learnt how to express yet. It consists of two parts. First is an optional character, and secondly is a range of characters.</p>

<p>This can be written using something called a <em>Regular Expression</em>. This is another way to write a <em>grammar</em>. Regular expressions are a way of writing grammars for small sections of text such as words or numbers. Grammars written using regular expressions can't consist of multiple rules, but they do give precise, and consise, control over what is matched and what isn't.</p>

<p>You&#39;ll notice this is written between two forward slashes <code>/</code>, which means it is a <em>regular expression</em> (another type of grammar). For now don&#39;t worry to much about the syntax as there are a lot to say about regular expressions that are beyond the scope of this tutorial. Basically the <code>?</code> means optional, the <code>+</code> means one or more of, and the <code>[0-9]</code> means in the range <code>0</code> to <code>9</code>. The next one is easy.</p>


<h3>Maths Grammar</h3>

<p>Putting everything together, the code for our maths language will look something like this.</p>

<pre><code class="lang-c">/* Create Some Parsers */
mpc_parser_t* Number   = mpc_new(&quot;number&quot;);
mpc_parser_t* Operator = mpc_new(&quot;operator&quot;);
mpc_parser_t* Expr     = mpc_new(&quot;expr&quot;);
mpc_parser_t* Lispy    = mpc_new(&quot;lispy&quot;);

/* Define them with the following Language */
mpca_lang(
  &quot;                                                     \
    number   : /-?[0-9]+/ ;                             \
    operator : &#39;+&#39; | &#39;-&#39; | &#39;*&#39; | &#39;/&#39; ;                  \
    expr     : &lt;number&gt; | &#39;(&#39; &lt;operator&gt; &lt;expr&gt;+ &#39;)&#39; ;  \
    lispy    : /^/ &lt;expr&gt; /$/ ;                         \
  &quot;,
  Number, Operator, Expr, Lispy);

/* Do some Parsing... */

/* Undefine and Delete our Parsers */
mpc_cleanup(4, Number, Operator, Expr, Lispy);</code></pre>

<p>So we create our four parsers using <code>mpc_new</code> and then define them using <code>mpca_lang</code>. We should put the first part of this code right at the beginning of our program, before any message is printed, and we should put the <code>mpc_cleanup</code> command at the end of our program right before returning from <code>main</code>.</p>

<p>Next we need to edit our <code>while</code> loop so that rather than just annoyingly echoing user input back it actually attempts to parse the input using our maths grammar. So take out the line with <code>fprintf</code> on and replace it with this code that attempts to parse the user input using our polish maths grammar.</p>

<pre><code>/* Attempt to Parse the Input */
mpc_result_t r;
if (mpc_parse(&quot;&lt;stdin&gt;&quot;, input, Lispy, &amp;r)) {

  /* On Success Print the AST */
  mpc_ast_print(r.output);
  mpc_ast_delete(r.output);
  puts(&quot;\n&quot;);

} else {

  /* Otherwise Print the Error */
  mpc_err_print(r.error);
  mpc_err_delete(r.error);

}</code></pre>

<p>Here we use the <code>mpc_parse</code> function with our parser <code>Lispy</code> on the <code>input</code>. We have to give a name for the source this input is coming from (we just call it <code>&lt;stdin&gt;</code> for now) and also we need to output the result to some variable. For this we declare a variable <code>r</code> of type <code>mpc_result_t</code> and then use the <em>address of</em> operator <code>&amp;</code> to get a pointer to it. We then give <code>mpc_parse</code> this pointer. A pointer is like a house number that <code>mpc_parse</code> can deliver to. Rather than giving our whole house to the <code>mpc_parse</code>, so that he can place a parcel on the mat at the front door, and give it back to us, we just give him our house number and ask him to send the result from where he is.</p>

<p>Don&#39;t worry too much for now if you don&#39;t understand, pointers are a famously hard part of C, so we&#39;ll cover them in more depth later.</p>

<p><code>mpc_parse</code> returns true or false depending on if the result of the parse was successful. If it is successful we just print out the <em>ast</em>, or <em>abstract syntax tree</em> it returns, otherwise we print out the error. Both the error and the <em>ast</em> returned have been newly created by <code>mpc_parse</code>, and it is our responsibility to delete them using the appropriate functions.</p>

<h3>Compilation and Running</h3>

<p>To compile this program you&#39;ll need to make sure you include <code>mpc</code>. For this go to the <code>mpc</code> repo <a href="http://github.com/orangeduck/mpc"><a href="http://github.com/orangeduck/mpc">http://github.com/orangeduck/mpc</a></a> and download <code>mpc.h</code> and <code>mpc.c</code>. Put these in the same directory as your source file. To the top of your source file add <code>#include &quot;mpc.h&quot;</code> to give you access to all the new mpc functions. Say your code is in a file called <code>example3.c</code> you can now attempt to compile this using:</p>

<p><code>cc -std=c99 -Wall example3.c mpc.c -lm -o example3</code></p>

<p>You should be able to run it in the same way as before. If successful it should look something like this.</p>

<pre><code>Lispy Version 0.0.0.0.2
Press Ctrl+c to Exit

lispy&gt; (+ 1 2)
root:
  expr:
    char: &#39;(&#39;
    operator: &#39;+&#39;
    expr: &#39;1&#39;
    expr: &#39;2&#39;
    char: &#39;)&#39;
  regex:


lispy&gt; (+ 5  (* 2 2) )
root:
  expr:
    char: &#39;(&#39;
    operator: &#39;+&#39;
    expr: &#39;5&#39;
    expr:
      char: &#39;(&#39;
      operator: &#39;*&#39;
      expr: &#39;2&#39;
      expr: &#39;2&#39;
      char: &#39;)&#39;
    char: &#39;)&#39;
  regex:


lispy&gt; hello
&lt;stdin&gt;:0:0: error: expected one or more of one of &#39;0123456789&#39; or &#39;(&#39; at &#39;h&#39;
lispy&gt; (/ 1dog &amp; cat)
&lt;stdin&gt;:0:4: error: expected &#39;)&#39; at &#39;d&#39;
lispy&gt; (- 5 -1)
root:
  expr:
    char: &#39;(&#39;
    operator: &#39;-&#39;
    expr: &#39;5&#39;
    expr: &#39;-1&#39;
    char: &#39;)&#39;
  regex:


lispy&gt;</code></pre>


<h3>Tutorial Code</h3>

<p><a href="">chapter5.c</a></p>

<h3>Bonus Marks</h3>

<ul>
  <li>Make a new operator like <code>%</code> available to use.</li>
  <li>Make the operators infix (that is between two numbers rather than before).</li>
  <li>Make the parser recognize some form of numbers in written format (e.g <code>one</code>, <code>two</code>, <code>three</code> ...).</li>
</ul>