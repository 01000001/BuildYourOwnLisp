<h1>Languages <small>&bull; Chapter 5</small></h1>


<h2>What is a Programming Language?</h2> <hr/>

<p>A programming language is very similar to a real language. There is a structure behind it, and some implicit rules as to what is, and isn't, a valid thing to say. When we read and write natural language, we use the same skills and brain processes as when we read and write code. We are unconciously learning these rules that govern languages, and can use them to understand others, as well as generate our own speech.</p>

<div class='pull-right alert alert-warning' style="margin: 15px; text-align: center;">
  <img src="/static/img/cat.png" alt="cat"/>
  <p><small>Cat &bull; cannot speak or program</small></p>
</div>

<p>In the 1950s the linguist <em>Noam Chomsky</em> formalised a number of important observations about languages. Many of these form the basis of our understanding of language today. One of these was the observation that natural languages are built up of recursive and repetative substructures.</p>

<p>An example of this is the phrase <code>The cat is black</code>. The adjective <code>black</code> can be replaced by two adjectives conjoined with <em>and</em>; for example <code>The cat is black and white</code>. Each of these new adjectives can in turn be replaced by further specification and variation. We can expand it to <code>the cat is jet black and a pale white</code>.</p>

<p>Exactly the same observation is true of programming languages. The body of an <code>if</code> statement can contain any number of new statements. One of these new statements could itself be another <code>if</code> statement, and so on.</p>

<p>The consequence of this observation is important. It means that although there is an infinite number of different things that can be said, or written down, in a particular language; it is still possible to process and understand it with a finite number of rules.</p>

<p>The name for these rules is a <em>grammar</em>. We can describe grammers in a number of ways. One way is textual. For example we can say, 'a <em>sentance</em> must contain a <em>verb phrase</em>', or 'a <em>verb phrase</em> can be either a <em>verb</em> or an <em>adverb</em> followed by a <em>verb phrase</em>'. This method is good for humans but it is too vague for computers to understand. When programming we need to write down a more formal description of a grammar.</p>

<p>We are going to do this for our Lisp. To be able to read in the user input we need to write a <em>grammar</em> which describes it. If we write this grammar we can use it along with our user input and decide if the input is valid. If it is valid we can build a structured internal representation, which we can then <em>evaluate</em>, and perform the commands encoded within.</p>

<p>This is where <code>mpc</code> comes in.</p>


<h2>Parser Combinators</h2> <hr/>

<p><code>mpc</code> is a <em>Parser Combinator</em> library. This is a library that allows you to build <em>parsers</em>. These are programs that understand and process particular languages. There are many different ways of building parsers, but the nice thing about using a <em>Parser Combinator</em> library is that it lets you build <em>parsers</em> easily, by specifying just the <em>grammar</em> ... sort of.</p>

<p>Many <em>Parser Combinator</em> libraries actually work by letting you write code that simply <em>looks like</em> a grammar, not by actually specifying the grammar itself. Often this is the best that can be done, but luckily for us <code>mpc</code> allows for both. It can let us write code that just <em>looks like</em> a grammar, but it can actually let us write a grammar directly too!</p>


<h2>Code that looks like a grammar</h2> <hr/>

<p>So what does code that <em>looks like</em> a grammar..<em>look like</em>? Here is a basic example of using <code>mpc</code> in this mode.</p>

<pre><code data-language='c'>void parse_flatmate(char* input) {

  /* Build a new parser 'Flatmate' */
  mpc_parser_t* Flatmate = mpc_or(4, 
    mpc_sym("Dan"),  mpc_sym("Chess"),
    mpc_sym("Adam"), mpc_sym("Lewis")
  );
  
  /* Attempt to parse into result 'r' */
  mpc_result_t r;
  if (mpc_parse("&lt;stdin&gt;", input, Flatmate, &r)) {
    /* On success report flatmate */
    printf("Got a flatmate %s!\n", (char*)r.output);
    free(r.output);
  } else {
    /* On Failure report nothing */
    printf("Not a flatmate!\n");
    mpc_err_delete(r.error);
  }
  
  mpc_delete(Flatmate);
}</code></pre>

<p>Although you wont recognize many of the functions above, see if you can guess what they do individually. Then try to guess what the code does as a whole. Don't worry if you don't really understand it all.</p>

<p>What this code does is create a new parser and trys to use it on <code>input</code>. The parser is successful if the input is equal to <em>either</em> <code>"Dan"</code>, <code>"Chess"</code>, <code>"Adam"</code> <em>or</em> <code>"Lewis"</code>. These are all the strings that can be successfully recognized by this parser, and so they are considered its <em>language</em>. On success it prints out the parsed string, otherwise it returns an error.</p>

<p>If you squint your eyes you could attempt to read the first section of the code like it is a weird grammar. It goes like this: 'a <em>Flatmate</em> is <code>"Dan"</code> or <code>"Chess"</code> or <code>"Adam"</code> or <code>"Lewis"</code>'.</p>

<p>We can built a more complicated parser by referencing existing ones.</p>

<pre><code data-language='c'>mpc_parser_t* Greet = mpc_and(2, mpcf_strfold,
  mpc_sym(&quot;Hello&quot;),
  Flatmate, 
  free); 

mpc_parser_t* Greetings = mpc_many(mpcf_strfold, Greet);</code></pre>

<p>In this example the parser <code>Greet</code> parses <code>&quot;Hello&quot;</code> followed by a <code>Flatmate</code> (<em>either</em> <code>"Dan"</code>, <code>"Chess"</code>, <code>"Adam"</code> <em>or</em> <code>"Lewis"</code>), and concatinates these two results together using the function <code>mpcf_strfold</code>.</p>

<p>The parser <code>Greetings</code> then expands on this by recognizing many (zero or more) occurrences of <code>Greet</code> parser.</p>

<p>Now there are an infinite number of different possible strings that could be accepted by our parser <code>Greetings</code>. This means it's language is <em>infinite</em>. Here are some examples of possible strings <code>Greetings</code> could accept.

<pre><code data-language='c'>&quot;Hello Dan&quot;
&quot;Hello Dan Hello Chess&quot;
&quot;Hello Lewis Hello Lewis Hello Lewis&quot;</code></pre>

</p> Again we can squint our eyes and try to read the above code as if it were a grammar. 'A <em>Greet</em>, is <code>"Hello"</code>, <em>and</em> a <em>Flatmate</em>, joined using <code>mpcf_strfold</code>', 'a <em>Greetings</em> is many <em>Greet</em>s joined using <code>mpcf_strfold</code>'.</p>

<p>If we use more functions and structures, we can slowly build up a parser that parses more and more complicated languages. The code we use <em>sort of</em> looks like a grammar. This isn&#39;t always an easy task but there are a whole set of helper functions that build on simple constructs to make frequent tasks easy. These are all documented on the <a href="http://github.com/orangeduck/mpc">mpc repository</a>. This is altogether a powerful approach but there is a simpler way too.</p>


<h2>A grammar itself</h2> <hr/>

<p>As I mentioned before, <code>mpc</code> actually lets you write the grammar directly, rather than using C functions to emulate it. When using this method you don&#39;t have to worry about how to join or discard inputs, with functions such as <code>mpcf_strfold</code>, or <code>free</code>.</p>

<p>Because of this it is a much easier approach, and this is why we are going to use it for our Lisp. Here is how we would recreate the previous examples using this method.</p>

<pre><code data-language='c'>mpc_parser_t* Flatmate  = mpc_new(&quot;flatmate&quot;);
mpc_parser_t* Greet     = mpc_new(&quot;greet&quot;);
mpc_parser_t* Greetings = mpc_new(&quot;greetings&quot;);

mpca_lang(
  &quot;                                                            \
    flatmate  : \&quot;Chess\&quot; | \&quot;Dan\&quot; | \&quot;Adam\&quot; | \&quot;Lewis\&quot;;    \
    greet     : \&quot;Hello\&quot; &lt;flatmate&gt;;                          \
    greetings : &lt;greet&gt;*;                                      \
  &quot;,
  Flatmate, Greet, Greetings);

/* Do Some Parsing... */

mpc_cleanup(3, Flatmate, Greet, Greetings);</code></pre>

<p>Without having a good understanding of what is going on, it should be clear how much <em>clearer</em> the grammar is in this format. If we learn what all the special symbols mean we barely have to squint our eyes to read it.</p>

<p>Another thing to notice is that the process is now in two steps. First we create and name several rules using <code>mpc_new</code> and then we define them using <code>mpca_lang</code>.</p>

<p>The first argument to <code>mpca_lang</code> is a long multi-line string in C. This is the fabled formal <em>grammar</em> specification you&#39;ve heard so much about. It consists of a number of <em>rules</em>. Each rule has the name of a parser on the left, a colon <code>:</code>, and on the right it&#39;s definition terminated with a semicolon <code>;</code>. The special symbols are defined as follows.</p>

<table class='table'>
  <tr><td><code>"ab"</code></td><td>A string <code>ab</code> is required.</td></tr>
  <tr><td><code>'a'</code></td><td>A character <code>a</code> is required.</td></tr>
  <tr><td><code>'a' 'b'</code></td><td>First <code>'a'</code> is required, then <code>'b'</code> is required..</td></tr>
  <tr><td><code>'a' | 'b'</code></td><td>Either <code>'a'</code> is required, or <code>'b'</code> is required.</td></tr>
  <tr><td><code>'a'*</code></td><td>Zero or more <code>'a'</code> are required.</td></tr>
  <tr><td><code>'a'+</code></td><td>One or more <code>'a'</code> are required.</td></tr>
  <tr><td><code>&lt;abba&gt;</code></td><td>The rule called <code>abba</code> is required.</td></tr>
</table>

<div class="alert alert-warning">
  <p><strong>Sounds familiar...</strong></p>

  <p>Did you notice that the above sort of sounded like I was specifying a grammar? That&#39;s because it was! <code>mpc</code> actually uses itself internally to parse the input you give it to <code>mpca_lang</code>. It does it by specifying a <em>grammar</em> similar to what I described above in text. How neat is that. It's grammars all the way down.</p>
</div>

<p>In the next chapter we are going to make use of this new knowledge to start specifying a grammar for a subset of our Lisp. Don't be discouraged if you feel this chapter has been too much at once. Grammars can be difficult to understand right away. You will become much more familar with how to create and edit them as we continue.</p>


<h2>Reference</h2> <hr/>

<div class="panel-group alert alert-warning" id="accordion">
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne">
          parse_flatmate.c
        </a>
      </h4>
    </div>
    <div id="collapseOne" class="panel-collapse collapse">
      <div class="panel-body">
<pre><code data-language='c'>#include "mpc.h"

void parse_flatmate(char* input) {

  /* Build a new parser 'Flatmate' */
  mpc_parser_t* Flatmate = mpc_or(4, 
    mpc_sym("Dan"),  mpc_sym("Chess"),
    mpc_sym("Adam"), mpc_sym("Lewis")
  );
  
  /* Attempt to parse into result 'r' */
  mpc_result_t r;
  if (mpc_parse("&lt;stdin&gt;", input, Flatmate, &r)) {
    /* On success report flatmate */
    printf("Got a flatmate %s!\n", (char*)r.output);
    free(r.output);
  } else {
    /* On Failure report nothing */
    printf("Not a flatmate!\n");
    mpc_err_delete(r.error);
  }
  
  mpc_delete(Flatmate);

}

int main(int argc, char** argv) {
  
  if (argc != 2) {
    puts("Usage: parser &lt;flatmate&gt;");
    return 0;
  }
  
  parse_flatmate(argv[1]);

  return 0;
}</code></pre>
      </div>
    </div>
  </div>
  
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo">
          greeting.c
        </a>
      </h4>
    </div>
    <div id="collapseTwo" class="panel-collapse collapse">
      <div class="panel-body">
<pre><code data-language='c'>#include "mpc.h"

int main(int argc, char** argv) {

  mpc_parser_t* Flatmate = mpc_or(4, 
    mpc_sym("Dan"),  mpc_sym("Chess"),
    mpc_sym("Adam"), mpc_sym("Lewis")
  );

  mpc_parser_t* Greet = mpc_and(2, mpcf_strfold,
    mpc_sym("Hello"),
    Flatmate, 
    free); 

  mpc_parser_t* Greetings = mpc_many(mpcf_strfold, Greet);

  mpc_delete(Greetings);
  
  return 0;
  
}</code></pre>
      </div>
    </div>
  </div>
  
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree">
          greeting_grammar.c
        </a>
      </h4>
    </div>
    <div id="collapseThree" class="panel-collapse collapse">
      <div class="panel-body">
<pre><code data-language='c'>#include "mpc.h"

int main(int argc, char** argv) {

  mpc_parser_t* Flatmate  = mpc_new("flatmate");
  mpc_parser_t* Greet     = mpc_new("greet");
  mpc_parser_t* Greetings = mpc_new("greetings");

  mpca_lang(
    "                                                            \
      flatmate  : \"Chess\" | \"Dan\" | \"Adam\" | \"Lewis\";    \
      greet     : \"Hello\" &lt;flatmate&gt;;                          \
      greetings : &lt;greet&gt;*;                                      \
    ",
    Flatmate, Greet, Greetings);

  /* Do Some Parsing... */

  mpc_cleanup(3, Flatmate, Greet, Greetings);
  
  return 0;
  
}</code></pre>
      </div>
    </div>
  </div>
  
</div>


<h2>Bonus Marks</h2> <hr/>

<div class="alert alert-warning">
  <ul class="list-group">
    <li class="list-group-item">&bull; Why are there back slashes <code>\</code> in front of the quote marks <code>"</code> in the grammar?</li>
    <li class="list-group-item">&bull; Description textually a grammar for a decimal number such as <code>0.01</code> or <code>52.221</code>.</li>
    <li class="list-group-item">&bull; Description textually a grammar for a simple english sentance such as <code>the cat sat on the mat</code>.</li>
    <li class="list-group-item">&bull; Description formally the above grammars. Use symbols such as <code>|</code> for <em>or</em>, and <code>*</code> for <em>zero or more of</em>.</li>
    <li class="list-group-item">&bull; If you are familiar with JSON or XML, consider what their grammars might look like. Sketch out a description.</li>
  </ul>
</div>


<h2>Navigation</h2>

<table class="table" style='table-layout: fixed;'>
  <tr>
    <td class="text-left"><a href="chapter4_interactive_prompt"><h4>&lsaquo; An Interactive Prompt</h4></a></td>
    <td class="text-center"><a href="contents"><h4>&bull; Contents &bull;</h4></a></td>
    <td class="text-right"><a href="chapter6_parsing"><h4>Parsing &rsaquo;</h4></a></td>
  </tr>
</table>
