<h2>Lists</h2>
<h3>Into the Lisp</h3>
<p>Some of you may have guessed that Lisp is a play on the word <em>list</em>, but so far we&#39;ve not really seen much of that fabled beast. In this chapter we rectify that, by finally converting our program into something that could vaguely be called a Lisp. This is a long chapter so brace yourself. But once we&#39;ve finished we will be over the hump toward a Lisp and ready to stop learning so many new things, and start putting our skills to use to create new features!</p>
<p>The first step of conversion to a Lisp is to change our program so that the input is represented internally using lists. The second step is to introduce a new kind of list we can use to store multiple values in.</p>
<p>By introducing lists we finally enter the world of Lisp - where thing differ by taste, and many people have different opinions on what is <em>right</em>.</p>
<p>Like a Highschool Physics teacher I may be about to teach you something that you will later find out to be <em>wrong</em>. But there is no need to panic. The reason I&#39;m doing it is that it is a valid simplification that aids understanding. It is an abstraction. Which are good. But it is still important to mention, because creating abstractions is not an objective task - there is some art to it. Like a physics professor with their own pet-theory of the universe, I&#39;ve become pretty fond of mine, but that doesn&#39;t mean you will be.</p>
<p>In this tutorial you are encouraged to change things to the way you want them. If you don&#39;t like the syntax then change it. If you want to call it something else then do. If you think the functions should be named something different then rename them. I think self-expression is the most important thing in programming so these are skills I want to teach. What I say for the rest of this tutorial is just a template. Keeping that in mind...</p>
<p>In our Lisp there are two types of list.</p>
<p>The first we are going to call S-Expressions (standing for <em>symbolic expression</em>). These are the lists of numbers, symbols, other S-Expressions and anything else, surrounded in parenthesis <code>()</code>. These are the guys we are used to so far. They are used to read in and store the actual structure of the program. Most importantly they have the particular evaluation behaviour typical of Lisps. That to evaluate an S-Expression we look at the first item in the list, and take this to be the operator. We then look at all the other items in the list and apply them to this first item to get the result.</p>
<p>The second type of list we are going to call Q-Expressions (standing for <em>quoted expression</em>). Again these are lists of numbers, symbols, and other Expressions, but these we put them in curly brackets <code>{}</code>. Q-Expressions are used to store lists of things we don&#39;t want to be evaluated. This could be numbers, functions, S-Expressions or anything else. When encountered by the evaluation function Q-Expressions are <em>not</em> evaluated like S-Expressions - they are left exactly as they are. This unique behaviour makes them ideal for a whole number of purposes we will encounter later.</p>
<p>Just using these two types of list, a handful of operators, and a bit of creativity, we can build a programming language that is insanely powerful and flexible.</p>
<h3>Pointers</h3>
<p>In C no concept of list can be explored without dealing properly with pointers. Pointers are a famously misunderstood aspect of C. They are difficult to teach because while being conceptually very simple, they come with a lot of new terminology, and often no clear use-case. This makes them appear far more monstrous than they are. Luckily for us, we have a couple ideal use-cases, both of which are extremely typical in C, and will likely end up being how you use pointers 90% of the time.</p>
<p>The reason we need pointers in C is because of how function calling works. When you call a function in C the arguments are always passed <em>by value</em>. This means a copy of them is passed to the function you call. This is true for <code>int</code>, <code>long</code>, <code>char</code>, and <code>struct</code>s such as <code>lval</code>. Most of the time this is great but occasionally it can cause issues. For example if we have a large struct containing many other sub structs suddenly the amount of data that needs to be copied around can become huge.</p>
<p>A second and more common program is that this data that is copied around must always be a fixed size. Otherwise the compiler has no way of generating valid code. So via normal means we can&#39;t call a function with a data structure of varying size, such as a dynamically-sized list.</p>
<p>To get around these issues computer scientists came up with a clever idea. One can visualize computer memory as a single huge list of bytes, where each one of these bytes can be given a global index or position in this list. Early computer scientists observed that using this idea, each piece of data, including the variables used in functions, exist at some known index. Rather than copying the data itself to the function that needs it, one can instead copy the index representing it&#39;s location in memory. This index is just a number itself, so <em>is</em> of a fixed size. This index is known as <em>the address</em> of the data.</p>
<p>By using addresses instead of the actual data one can allow a function to access and modify some location in memory without making a copy of it. We can also get functions to output to some location by passing in the index of the data we want them to modify.</p>
<p>The size of an address always the same. But if we keep track of it, the number of bytes at that index meant to represent some data structure can grown and shrink over time. This means one can create a variable sized data-structure and still <em>pass</em> it to a function, which can inspect and modify it.</p>
<p>We can declare pointer types using the <code>*</code> character. You will have seen these already in the form of <code>mpc_parser_t*</code>, which reads <em>a pointer to a mpc parser</em>. To get the address of a some data we use the <code>&amp;</code> operator. Again you&#39;ve seen this before when we passed in a pointer to <code>mpc_parse</code>. Thirdly we can <em>dereference</em> a pointer using <code>*</code> on the left hand size. This means to get the data value at a pointer address.</p>
<h3>The Stack &amp; The Heap</h3>
<p>Memory can be thought of as one long array of bytes, but actually it is split into two sections. These are called <em>The Stack</em> and <em>The Heap</em>.</p>
<p>Some of you may have heard tales of these mysterious locations, such as <em>the stack grows down but the heap grows up</em>, or <em>there can be many stacks, but only one heap</em>. Ignore this gossip spread by Perl and Java programmers. In C the stack and the heap are commonplace - and you will learn to know them well.</p>
<p>The stack is the memory where your program&#39;s local variables live. Each time you call a function a new area of the stack is put aside for it&#39;s execution. In this area is contained any local variables the function requires, a copy of any parameters it has been passed, as well as some bookkeeping data. When the function is done the area it used is unallocated ready for use again.</p>
<p>The heap is a section of memory put aside for storage of objects with a longer lifespan. The way to allocate space in this location is to use the <code>malloc</code> function. This function takes in some number of bytes requested and returns a pointer to a new block of memory with that many bytes.</p>
<p>Unlike the stack, the heap has no way of knowing when you are done with it. Therefore it is important to notify the system by calling the <code>free</code> function on a pointer you&#39;ve retrieved from <code>malloc</code>. Otherwise it will persist and our program will leak memory.</p>
<p>I like to think of the stack as a building site. Each time we need to do something new we corner of a section of space, enough for our tools and materials, and set to work. We can still go to other parts of the site, of visit the heap, if we need certain things, but all our work is done in this section. Once we are done we take what we&#39;ve constructed to a new side and deallocated that section of the space.</p>
<p>The heap is like a U-Store-It. We can call up the reception with <code>malloc</code> and request a number of boxes. With these boxes we can do what we want and we know they will persist no matter how messy the building site gets. It is useful to store materials and large objects there which we only need to retrieve once in a while. The only problem is we need to remember to call the receptionist again with <code>free</code> when we are done. Otherwise soon we&#39;ll have requested all the boxes and will run out of memory.</p>
<h3>List Structure</h3>
<p>Wow - that was a lot to take in. Lets see some of it in action. First we modify our <code>lval</code> struct to have some extra fields. It needs to contain a pointer to zero or more other <code>lval</code> pointers and a record of how many are pointed to.</p>
<pre><code class="lang-c">/* Add SEXPR and QEXPR as possible lval types. Also add &quot;Symbol&quot; as possible type */
enum { LVAL_ERR, LVAL_NUM, LVAL_SYM, LVAL_SEXPR, LVAL_QEXPR };

typedef struct lval {
  int type;

  long num;

  /* Error and Symbol types have some string data */
  char* err;
  char* sym;

  /* Record Number of other &quot;lvals&quot; references and a pointer to a list of &quot;lval&quot; pointers */
  int count;
  struct lval** cell;

} lval;</code></pre>
<p>We change the <code>LVAL_ERR</code> type data to be a string (A.K.A a <code>char*</code>). This means we can store a unique error message rather than just an error code. This will make our error reporting better and more flexible.</p>
<p>We also need to add another new type <code>LVAL_SYM</code>. This type also uses <code>char*</code> for it&#39;s data, and it is used to score function names such as <code>+</code>, <code>-</code> or others we will see later. This is required for the behaviour of our new <em>quoted</em> expressions which in themselves can contain S-Expressions with values such as <code>+</code>.</p>
<p>Finally we add two new data fields used by our list types. The first is a <code>count</code> of the number of items in the list, and the second is a pointer to a block of data. This block of data contains a number of <code>lval*</code> - pointers to other <code>lval</code>s. So here we see something particular in C, a <em>pointer to some pointers</em>.</p>
<p>Because our <code>lval</code> structure now contains pointers to other things such as strings or other <code>lval</code>s we now should always pass around pointers to <code>lval</code>s. This is so that we always can easily clean up resources allocated by each. To start we need to modify our creation functions to construct <code>lval*</code>s.</p>
<pre><code class="lang-c">/* Construct a pointer to a new Number lval */ 
lval* lval_num(long x) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_NUM;
  v-&gt;num = x;
  return v;
}

/* Construct a pointer to a new Error lval */ 
lval* lval_err(char* m) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_ERR;
  v-&gt;err = malloc(strlen(m) + 1);
  strcpy(v-&gt;err, m);
  return v;
}

/* Construct a pointer to a new Symbol lval */ 
lval* lval_sym(char* s) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_SYM;
  v-&gt;sym = malloc(strlen(s) + 1);
  strcpy(v-&gt;sym, s);
  return v;
}

/* A pointer to a new empty Sexpr lval */
lval* lval_sexpr(void) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_SEXPR;
  v-&gt;count = 0;
  v-&gt;cell = NULL;
  return v;
}

/* A pointer to a new empty Qexpr lval */
lval* lval_qexpr(void) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_QEXPR;
  v-&gt;count = 0;
  v-&gt;cell = NULL;
  return v;
}</code></pre>
<p>These functions allocate new <code>lval</code>s on the heap using <code>malloc</code>. You&#39;ll see something new here which is the <code>-&gt;</code> operator. This is used to set or get a member of a pointer to a struct. It is like the <code>.</code> operator we&#39;ve been using before except it is used on pointer types.</p>
<p>Because our <code>lval</code>s are now allocated using <code>malloc</code>, we need to make sure to free them using <code>free</code>. For this we need to create a <code>lval_del</code> function that can delete any <code>lval</code> and all of the <code>lval</code>s contained inside or any of the other allocations.</p>
<pre><code class="lang-c">void lval_del(lval* v) {

  switch (v-&gt;type) {
    /* Do nothing special for number type */
    case LVAL_NUM: break;

    /* For Err or Sym free the string data */
    case LVAL_ERR: free(v-&gt;err); break;
    case LVAL_SYM: free(v-&gt;sym); break;

    /* If Qexpr or Sexpr then delete all elements inside */
    case LVAL_QEXPR:
    case LVAL_SEXPR:
      for (int i = 0; i &lt; v-&gt;count; i++) {
        lval_del(v-&gt;cell[i]);
      }
      /* Also free the memory allocated to contain the pointers */
      free(v-&gt;cell);
    break;
  }

  /* Finally free the memory allocated for the &quot;lval&quot; struct itself */
  free(v);
}</code></pre>
<p>Now if we use <code>lval_del</code> for every <code>lval*</code> allocated with our above construction functions we can ensure we will get no memory leaks.</p>
<p>So now we have a <code>lval</code> which can act as list-like data type. Our first task is too add support for these Sexpressions and Qexpressions to the parser grammar. We add two new basic parse rules and add them as options of the <code>expr</code> rule.</p>
<pre><code class="lang-c">  mpc_parser_t* Number = mpc_new(&quot;number&quot;);
  mpc_parser_t* Symbol = mpc_new(&quot;symbol&quot;);
  mpc_parser_t* Sexpr  = mpc_new(&quot;sexpr&quot;);
  mpc_parser_t* Qexpr  = mpc_new(&quot;qexpr&quot;);
  mpc_parser_t* Expr   = mpc_new(&quot;expr&quot;);
  mpc_parser_t* Lispy  = mpc_new(&quot;lispy&quot;);

  mpca_lang(
    &quot;                                                     \
      number : /-?[0-9]+/ ;                               \
      symbol : &#39;+&#39; | &#39;-&#39; | &#39;*&#39; | &#39;/&#39; ;                    \
      sexpr  : &#39;(&#39; &lt;expr&gt;* &#39;)&#39; ;                          \
      qexpr  : &#39;{&#39; &lt;expr&gt;* &#39;}&#39; ;                          \
      expr   : &lt;number&gt; | &lt;symbol&gt; | &lt;sexpr&gt; | &lt;qexpr&gt; ;  \
      lispy  : /^/ &lt;expr&gt;* /$/ ;                          \
    &quot;,
    Number, Symbol, Sexpr, Qexpr, Expr, Lispy);</code></pre>
<p>After these changes we can parse Qexpressions and Sexpressions such that they appear in the Abstract Syntax Tree, but we still can&#39;t make use of them. The next step is to to change our evaluation of the user input into two steps. First we want to <em>read</em> the input and construct an <code>lval*</code> of type Sexpression. Then we want to <em>evaluate</em> this Sexpression and return the result.</p>
<pre><code class="lang-c">lval* lval_read_num(mpc_ast_t* t) {
  long x = strtol(t-&gt;contents, NULL, 10);
  return errno != ERANGE ? lval_num(x) : lval_err(&quot;invalid number&quot;);
}

lval* lval_read(mpc_ast_t* t) {

  /* If Symbol or Number return conversion to that type */
  if (strstr(t-&gt;tag, &quot;number&quot;)) { return lval_read_num(t); }
  if (strstr(t-&gt;tag, &quot;symbol&quot;)) { return lval_sym(t-&gt;contents); }

  /* If root (&gt;), sexpr or qexpr then create empty list */
  lval* x = NULL;
  if (strcmp(t-&gt;tag, &quot;&gt;&quot;) == 0) { x = lval_sexpr(); } 
  if (strstr(t-&gt;tag, &quot;sexpr&quot;))  { x = lval_sexpr(); }
  if (strstr(t-&gt;tag, &quot;qexpr&quot;))  { x = lval_qexpr(); }

  /* Fill this list with any valid expression contained within */
  for (int i = 0; i &lt; t-&gt;children_num; i++) {
    if (strcmp(t-&gt;children[i]-&gt;contents, &quot;(&quot;) == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;contents, &quot;)&quot;) == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;contents, &quot;}&quot;) == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;contents, &quot;{&quot;) == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;tag,  &quot;regex&quot;) == 0) { continue; }
    x = lval_add(x, lval_read(t-&gt;children[i]));
  }

  return x;
}</code></pre>
<p>This is fairly straight-forward code. If the given ast node is a <code>number</code> or <code>symbol</code> then it returns an <code>lval*</code> for those types. If it is the root, an <code>sexpr</code> or a <code>qexpr</code> then it created an empty list and slowly adds each valid expression contained within. To do this is reads the child of the <code>ast</code> and then appends it to the <code>lval*</code> using <code>lval_add</code>. This is a function I&#39;ve not defined yet but it looks like this:</p>
<pre><code class="lang-c">lval* lval_add(lval* v, lval* x) {
  v-&gt;count++;
  v-&gt;cell = realloc(v-&gt;cell, sizeof(lval*) * v-&gt;count);
  v-&gt;cell[v-&gt;count-1] = x;
  return v;
}</code></pre>
<p>This increases the count of the list by one, and then uses <code>realloc</code> to reallocate the amount of space required by <code>v-&gt;cell</code> to store all the pointers to all the <code>lval</code>s contained within. It then sets the final value of the list with <code>v-&gt;cell[v-&gt;count-1]</code> to the value <code>x</code> passed in. It returns the newly modified <code>lval*</code>.</p>
<p>We can test our code up to this point by modifying our print function to take <code>lval*</code> and to be able to print our new list types.</p>
<pre><code class="lang-c">void lval_print(lval* v);

void lval_expr_print(lval* v, char open, char close) {
  putchar(open);
  for (int i = 0; i &lt; v-&gt;count; i++) {

    /* Print Value contained within */
    lval_print(v-&gt;cell[i]);

    /* Don&#39;t print trailing space if last element */
    if (i != (v-&gt;count-1)) {
      putchar(&#39; &#39;);
    }
  }
  putchar(close);
}

void lval_print(lval* v) {
  switch (v-&gt;type) {
    case LVAL_NUM:   printf(&quot;%li&quot;, v-&gt;num); break;
    case LVAL_ERR:   printf(&quot;Error: %s&quot;, v-&gt;err); break;
    case LVAL_SYM:   printf(&quot;%s&quot;, v-&gt;sym); break;
    case LVAL_SEXPR: lval_expr_print(v, &#39;(&#39;, &#39;)&#39;); break;
    case LVAL_QEXPR: lval_expr_print(v, &#39;{&#39;, &#39;}&#39;); break;
  }
}

void lval_println(lval* v) { lval_print(v); putchar(&#39;\n&#39;); }</code></pre>
<p>Then in our main loop, instead of evaluation, we can try simply reading in the result and printing out what we have read.</p>
<pre><code class="lang-c">lval* x = lval_read(r.output);
lval_println(x);
lval_del(x);</code></pre>
<p>If this is successful you should see something like the following when entering input to your program.</p>
<pre><code>lispy&gt; + 2 2
(+ 2 2)
lispy&gt; + 2 (* 7 6) (* 2 5)
(+ 2 (* 7 6) (* 2 5))
lispy&gt; *     55     101  (+ 0 0 0)
(* 55 101 (+ 0 0 0))
lispy&gt;</code></pre>
<p>Our evaluation functions remain largely similar except for the fact now that they take as input some <code>lval*</code> and must return some <code>lval*</code>. We can think of our evaluation function as a transformer. It takes in some <code>lval*</code> and transforms it in some way to some new <code>lva*</code>. It may just return the same thing, or it may modify the input <code>lval*</code> and the return it. But often we want to return something completel different. This means we must always remember to delete the input <code>lval*</code> before we return our new one.</p>
<p>If we stick to this behaviour we know we wont introduce any memory leaks.</p>
<pre><code class="lang-c">lval* lval_eval_sexpr(lval* v) {

  /* Evaluate Children */
  for (int i = 0; i &lt; v-&gt;count; i++) {
    v-&gt;cell[i] = lval_eval(v-&gt;cell[i]);
  }

  /* Error Checking */
  for (int i = 0; i &lt; v-&gt;count; i++) {
    if (v-&gt;cell[i]-&gt;type == LVAL_ERR) { return lval_take(v, i); }
  }

  /* Empty Expression */
  if (v-&gt;count == 0) { return v; }

  /* Single Expression */
  if (v-&gt;count == 1) { return lval_take(v, 0); }

  /* Ensure First Element is Symbol Start */
  lval* f = lval_pop(v, 0);
  if (f-&gt;type != LVAL_SYM) { lval_del(f); lval_del(v); return lval_err(&quot;S-expression Does not start with symbol!&quot;); }

  /* Call builtin with operator */
  lval* result = builtin_op(v, f-&gt;sym);
  lval_del(f);
  return result;
}

lval* lval_eval(lval* v) {
  /* Evaluate Sexpressions */
  if (v-&gt;type == LVAL_SEXPR) { return lval_eval_sexpr(v); }
  /* All other lval types remain the same */
  return v;
}</code></pre>
<p>The new Sexpr evaluation function works in a number of phases. The first phase is to evaluate all of the contents of the Sexpression. This ensure that any Sexpressions contained within will be evaluated before they are passed to any function.</p>
<p>The second phase is to check for any errors. If there are any errors we want to catch them immediately and propagate them outward. For this we use the <code>lval_take</code> function which extracts an item inside an Sexpression and deletes the Sexpression containing it. It is defined in two parts as follows:</p>
<pre><code class="lang-c">lval* lval_pop(lval* v, int i) {
  /* Find the item at &quot;i&quot; */
  lval* x = v-&gt;cell[i];

  /* Shift the memory following the item at &quot;i&quot; over the top of it */
  memmove(&amp;v-&gt;cell[i], &amp;v-&gt;cell[i+1], sizeof(lval*) * (v-&gt;count-i-1));

  /* Decrease the count of items in the list */
  v-&gt;count--;

  /* Reallocate the memory used */
  v-&gt;cell = realloc(v-&gt;cell, sizeof(lval*) * v-&gt;count);
  return x;
}

lval* lval_take(lval* v, int i) {
  lval* x = lval_pop(v, i);
  lval_del(v);
  return x;
}</code></pre>
<p>As you can see it first extracts an element from a list using <code>lval_pop</code>, and then deletes the outer list which no longer contains that item.</p>
<p>Back to our evaluation. Once we have evaluated all the expressions within and checked for errors we can try to evaluate properly this expression.</p>
<p>First if the expression is empty it simply returns it directly. If there is a single element in the Sexpression then it takes this using <code>lval_take</code>.</p>
<p>If neither of these are the case we know there is at least two elements in the Sexpression. We need to check the first item in this list to make sure it is a symbol - and if so use the value of the symbol to perform some operation using the function <code>builtin_op</code> - again a slight modification of our existing code to work correctly with <code>lval*</code>.</p>
<pre><code class="lang-c">lval* builtin_op(lval* a, char* op) {

  /* Pop the first element */
  lval* x = lval_pop(a, 0);

  /* If no arguments and sub then perform unary negation */
  if ((strcmp(op, &quot;-&quot;) == 0) &amp;&amp; a-&gt;count == 0) { x-&gt;num = -x-&gt;num; }

  /* While there are still elements remaining */
  while (a-&gt;count &gt; 0) {

    /* Pop the next element */
    lval* y = lval_pop(a, 0);

    /* Ensure these elements are of the correct type */
    if (x-&gt;type != LVAL_NUM) { lval_del(x); lval_del(y); x = lval_err(&quot;Cannot operator on non number!&quot;); break; }
    if (y-&gt;type != LVAL_NUM) { lval_del(x); lval_del(y); x = lval_err(&quot;Cannot operator on non number!&quot;); break; }

    /* Perform operation */
    if (strcmp(op, &quot;+&quot;) == 0) { x-&gt;num += y-&gt;num; }
    if (strcmp(op, &quot;-&quot;) == 0) { x-&gt;num -= y-&gt;num; }
    if (strcmp(op, &quot;*&quot;) == 0) { x-&gt;num *= y-&gt;num; }
    if (strcmp(op, &quot;/&quot;) == 0) {
      if (y-&gt;num == 0) { lval_del(x); lval_del(y); x = lval_err(&quot;Division By Zero!&quot;); break; }
      else { x-&gt;num /= y-&gt;num; }
    }

    /* Delete element now finished with */
    lval_del(y);
  }

  /* Delete input expression and return result */
  lval_del(a);
  return x;
}</code></pre>
<p>If all this is successful then you should now be able to evaluate expressions correctly in the same way as in the previous chapter.</p>
<pre><code>lispy&gt; + 1 2 3
6
lispy&gt; + 1 (* 7 5) 3
39
lispy&gt; / 6 {5 6}
Error: Cannot operator on non number!</code></pre>
<p>We&#39;ve got all the ground work in place but our list type is still useless - at the moment it can&#39;t be used in any of other mathematical operations and there is no way to manipulate it. It can be parsed but just throws an error whenever we operate on it.</p>
<p>What we need to do is add some builtin operations to work on our list type, much like how <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code> work on our number type. We can achieve all we wish to do with lists using just 5 operations on lists too. These are called <code>list</code>, <code>head</code>, <code>tail</code>, <code>join</code> and <code>eval</code>. Their intended behaviour is the following.</p>
<ul>
<li><code>list</code> should take one or more arguments and return a new list containing them</li>
<li><code>head</code> should take a list and return a list consisting of the first element in a list only</li>
<li><code>tail</code> should take a list and return a list missing the first element</li>
<li><code>join</code> should take one or more lists and return a new list of them conjoined together</li>
<li><code>eval</code> should convert a list to Sexpression and evaluate it</li>
</ul>
<p>As always our first step is to add support for these symbols in our parser.</p>
<pre><code class="lang-c">mpca_lang(
  &quot;                                                                                         \
    number : /-?[0-9]+/ ;                                                                   \
    symbol : \&quot;list\&quot; | \&quot;head\&quot; | \&quot;tail\&quot; | \&quot;eval\&quot; | \&quot;join\&quot; | &#39;+&#39; | &#39;-&#39; | &#39;*&#39; | &#39;/&#39; ; \
    sexpr  : &#39;(&#39; &lt;expr&gt;* &#39;)&#39; ;                                                              \
    qexpr  : &#39;{&#39; &lt;expr&gt;* &#39;}&#39; ;                                                              \
    expr   : &lt;number&gt; | &lt;symbol&gt; | &lt;sexpr&gt; | &lt;qexpr&gt; ;                                      \
    lispy  : /^/ &lt;expr&gt;* /$/ ;                                                              \
  &quot;,
  Number, Symbol, Sexpr, Qexpr, Expr, Lispy)</code></pre>
<p>Then we have to define them similarly to how our builtin operators are defined. These functions are easy enough in concept but unfortunately are a little laborious to actually write in code because of the amount of error checking required. Luckily the first one, <code>list</code> is super easy. Just convert the arguments type to a quoted expession and return.</p>
<pre><code class="lang-c">lval* builtin_list(lval* a) {
  a-&gt;type = LVAL_QEXPR;
  return a;
}</code></pre>
<p>Taking the head and tail of a list require more error checking. First we must ensure there is only a single argument. Secondly we must ensure it&#39;s type is <code>QEXPR</code>, and finally we must ensure it isn&#39;t the empty list. The head or tail of the empty list is undefined. An initial attempt might look like this.</p>
<pre><code class="lang-c">lval* builtin_head(lval* a) {
  /* Check Error Conditions */
  if (a-&gt;count != 1) { lval_del(a); return lval_err(&quot;Function &#39;head&#39; passed too many arguments!&quot;); }
  if (a-&gt;cell[0]-&gt;type != LVAL_QEXPR) { lval_del(a); return lval_err(&quot;Function &#39;head&#39; passed incorrect types!&quot;); }
  if (a-&gt;cell[0]-&gt;count == 0) { lval_del(a); return lval_err(&quot;Function &#39;head&#39; passed {}!&quot;); }

  /* Otherwise take first argument */
  lval* v = lval_take(a, 0);

  /* Delete all elements that are not head and return */
  while (v-&gt;count &gt; 1) { lval_del(lval_pop(v, 1)); }
  return v;
}

lval* builtin_tail(lval* a) {
  /* Check Error Conditions */
  if (a-&gt;count != 1) { lval_del(a); return lval_err(&quot;Function &#39;tail&#39; passed too many arguments!&quot;); }
  if (a-&gt;cell[0]-&gt;type != LVAL_QEXPR) { lval_del(a); return lval_err(&quot;Function &#39;tail&#39; passed incorrect types!&quot;); }  
  if (a-&gt;cell[0]-&gt;count == 0) { lval_del(a); return lval_err(&quot;Function &#39;tail&#39; passed {}!&quot;); }

  /* Take first argument */
  lval* v = lval_take(a, 0);

  /* Delete first element and return */
  lval_del(lval_pop(v, 0));
  return v;
}</code></pre>
<p>This is a bit of a mess. One way to clean it up is to use a <em>macro</em>. A macro in C is like a function that is evaluated before the program is compiled. It can be used to generate code and more. You can pass in as arguments almost anything and it will copy and paste their exact value into the structure specified.</p>
<p>Here is a macro called <code>LASSERT</code> that can help with our error conditions. We define macros using the <code>#define</code> preprocessor directive and give them a name in all capitals to help distinguish them from normal C functions.</p>
<pre><code class="lang-c">#define LASSERT(args, cond, err) if (!(cond)) { lval_del(args); return lval_err(err); }</code></pre>
<p>Essentially what this macro does is take in three arguments (<code>args</code>, <code>cond</code> and <code>err</code>) and uses them to generate code. It outputs code as shown to the right, but with these variables pasted in. We can use this to neaten up our above code. In the end it generates exactly the same thing as before, but makes it much easier to read for the programmer.</p>
<pre><code class="lang-c">lval* builtin_head(lval* a) {
  LASSERT(a, (a-&gt;count == 1                 ), &quot;Function &#39;head&#39; passed too many arguments!&quot;);
  LASSERT(a, (a-&gt;cell[0]-&gt;type == LVAL_QEXPR), &quot;Function &#39;head&#39; passed incorrect type!&quot;);
  LASSERT(a, (a-&gt;cell[0]-&gt;count != 0        ), &quot;Function &#39;head&#39; passed {}!&quot;);

  lval* v = lval_take(a, 0);  
  while (v-&gt;count &gt; 1) { lval_del(lval_pop(v, 1)); }
  return v;
}

lval* builtin_tail(lval* a) {
  LASSERT(a, (a-&gt;count == 1                 ), &quot;Function &#39;tail&#39; passed too many arguments!&quot;);
  LASSERT(a, (a-&gt;cell[0]-&gt;type == LVAL_QEXPR), &quot;Function &#39;tail&#39; passed incorrect type!&quot;);
  LASSERT(a, (a-&gt;cell[0]-&gt;count != 0        ), &quot;Function &#39;tail&#39; passed {}!&quot;);

  lval* v = lval_take(a, 0);  
  lval_del(lval_pop(v, 0));
  return v;
}</code></pre>
<p>We can also define the <code>eval</code> function fairly easily accommodating for the various error conditions. <code>eval</code> is like the opposite of <code>list</code>. It takes a single Qexpression and just changes it&#39;s type to <code>SEXPR</code> before running <code>lval_eval</code> on it.</p>
<pre><code>lval* builtin_eval(lval* a) {
  LASSERT(a, (a-&gt;count == 1                 ), &quot;Function &#39;eval&#39; passed too many arguments!&quot;);
  LASSERT(a, (a-&gt;cell[0]-&gt;type == LVAL_QEXPR), &quot;Function &#39;eval&#39; passed incorrect type!&quot;);

  lval* x = lval_take(a, 0);
  x-&gt;type = LVAL_SEXPR;
  return lval_eval(x);
}</code></pre>
<p>The <code>join</code> function is our final one to define and it&#39;s structure looks much like that of <code>builtin_op</code>. We take each argument in turn, ensure that it is of type <code>QEXPR</code> and then join it into the first one using a function <code>lval_join</code>.</p>
<pre><code class="lang-c">
lval* lval_join(lval* x, lval* y) {

  /* For each cell in &#39;y&#39; add it to &#39;x&#39; */
  for (int i = 0; i &lt; y-&gt;count; i++) {
    x = lval_add(x, y-&gt;cell[i]);
  }

  /* Free &#39;c&#39;s list of cells and itself */
  free(y-&gt;cell);
  free(y);

  /* Return &#39;x&#39; */
  return x;
}

lval* builtin_join(lval* a) {
  LASSERT(a, (a-&gt;cell[0]-&gt;type == LVAL_QEXPR), &quot;Function &#39;join&#39; passed incorrect type!&quot;);
  lval* x = lval_pop(a, 0);

  while (a-&gt;count) {
    lval* y = lval_pop(a, 0);
    if (x-&gt;type != LVAL_QEXPR) { lval_del(x); lval_del(y); x = lval_err(&quot;Function &#39;join&#39; passed incorrect type!&quot;); break; }
    if (y-&gt;type != LVAL_QEXPR) { lval_del(x); lval_del(y); x = lval_err(&quot;Function &#39;join&#39; passed incorrect type!&quot;); break; }
    x = lval_join(x, y);
  }

  lval_del(a);
  return x;
}</code></pre>
<p>Now that we have all the builtin functions defined we need to make a single one that calls the correct one depending on the symbol it encounters.</p>
<pre><code class="lang-c">lval* builtin(lval* a, char* func) {
  if (strcmp(&quot;list&quot;, func) == 0) { return builtin_list(a); }
  if (strcmp(&quot;head&quot;, func) == 0) { return builtin_head(a); }
  if (strcmp(&quot;tail&quot;, func) == 0) { return builtin_tail(a); }
  if (strcmp(&quot;join&quot;, func) == 0) { return builtin_join(a); }
  if (strcmp(&quot;eval&quot;, func) == 0) { return builtin_eval(a); }
  if (strstr(&quot;+-/*&quot;, func)) { return builtin_op(a, func); }
  lval_del(a);
  return lval_err(&quot;Unknown Function!&quot;);
}</code></pre>
<p>And finally change our evaluation line in <code>lval_eval_sexpr</code> to call <code>builtin</code> rather than <code>builtin_op</code>.</p>
<pre><code>/* Call builtin with operator */
lval* result = builtin(v, func-&gt;sym);
lval_del(func);
return result;</code></pre>
<p>And with that, lists should now be supported in our language! We can do some pretty nifty and unexpected things already by putting code and symbols into our lists which we then evaluate later</p>
<pre><code>lispy&gt; list 1 2 3 4
{1 2 3 4}
lispy&gt; {head (list 1 2 3 4)}
{head (list 1 2 3 4)}
lispy&gt; eval {head (list 1 2 3 4)}
{1}
lispy&gt; tail {tail tail tail}
{tail tail}
lispy&gt; eval (tail {tail tail {5 6 7}})
{6 7}
lispy&gt; eval (head {(+ 1 2) (+ 10 20)})
3</code></pre>
<h3>Tutorial Code</h3>
<p><a href="">example6.c</a></p>
<h3>Bonus Marks</h3>
<ul>
<li>Add a <code>len</code> function that returns the length of a list.</li>
<li>Add a <code>init</code> function that returns all of a list except the last element.</li>
<li>Create a macro to deal neatly with the error conditions inside the while loop of <code>builtin_op</code> and <code>builtin_join</code>.</li>
</ul>