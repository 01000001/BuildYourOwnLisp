<h1>Into Lisp <small>&bull; Chapter 9</small></h1>


<h2>Lists</h2>

<p>In the first chapter I mentioned that a Lisp is a language based around lists, but so far, other than our <em>abstract syntax tree</em>, we've not seen many of them. In this chapter we rectify that, by finally converting our program into something that could vaguely be called a Lisp. This is a long chapter, so brace yourself. But once we&#39;ve finished we will be over a big hill and on the downward slope toward a Lisp full of cool features.</p>

<p>Our knowledge of C should also be at the point where we can explore a little more, and start putting our skills to the test.</p>

<p>Our first step toward a Lisp will be to change our program to convert the <em>abstract syntax tree</em> input into an internal list structure to evaluate. The second step will be to introduce a new kind of list we can use to store values we don't want to be evaluated right away.</p>


<h2>Becoming a Lisp</h2>

<div class='pull-right alert alert-warning' style="margin: 15px; text-align: center;">
  <img src="/static/img/lisp.png" alt="lisp"/>
  <p><small>ALL CAPS &bull; SO RIGHT YET SO WRONG.</small></p>
</div>

<p>By introducing lists we finally enter the world of Lisp - where thing differ by taste, and many people have different opinions on what is <em>right</em>.</p>

<p>Like a Highschool Physics teacher I may be about to teach you something that you will later find out to be <em>wrong</em>. But there is no need to panic. The reason I&#39;m doing it is that it is a valid simplification that aids understanding. It is an abstraction. These are good. But it is still important to mention, because creating abstractions is not an objective task - there is some art to it. Like a physics professor with their own pet-theory of the universe, I&#39;ve become pretty fond of mine, but that doesn&#39;t mean you will be.</p>

<p>From this section on you are encouraged even more to change things to the way you want them. If you don&#39;t like the syntax then change it. If you want to call something something else, then do. To enjoy programming, maintaining self expression is the most important thing, and it is something I want to teach.</p>

<p>Keeping that in mind...</p>


<h2>Types of list</h2>

<p>In our Lisp there are going to be two types of list.</p>

<p>The first we are going to call S-Expressions (standing for <em>symbolic expression</em>). These are the lists of numbers, symbols, other Expressions that are surrounded in parenthesis <code>()</code>. These are the guys we have used to so far. We will use them to read in and store the actual structure of the program. But most importantly they have the particular evaluation behaviour typical of Lisps. That to evaluate an S-Expression we look at the first item in the list, and take this to be the operator. We then look at all the other items in the list, and take these as operands to get the result.</p>

<p>The second type of list we are going to call Q-Expressions (standing for <em>quoted expression</em>). Again these are lists of numbers, symbols, and other Expressions, but these we put in curly brackets <code>{}</code>. Q-Expressions are used to store lists of things we don&#39;t want to be evaluated. This could be numbers, functions, S-Expressions or anything else. When encountered by the evaluation function Q-Expressions are <em>not</em> evaluated like S-Expressions - they are left exactly as they are. This unique behaviour makes them ideal for a whole number of purposes we will encounter later.</p>

<p>Just using these two types of list, a handful of operators, and a bit of creativity, we can build a programming language that is incredibly powerful and flexible.</p>


<h2>Pointers</h2>

<p>In C no concept of list can be explored without dealing properly with pointers. Pointers are a famously misunderstood aspect of C. They are difficult to teach because while being conceptually very simple, they come with a lot of new terminology, and often no clear use-case. This makes them appear far more monstrous than they are. Luckily for us, we have a couple ideal use-cases, both of which are extremely typical in C, and will likely end up being how you use pointers 90% of the time.</p>

<p>The reason we need pointers in C is because of how function calling works. When you call a function in C the arguments are always passed <em>by value</em>. This means a copy of them is passed to the function you call. This is true for <code>int</code>, <code>long</code>, <code>char</code>, and user defined <code>struct</code> such as <code>lval</code>. Most of the time this is great but occasionally it can cause issues.</p>

<p>A common problem is if we have a large struct containing many other sub structs we wish to pass around. Every time we call a function we must create another copy of it. Suddenly the amount of data that needs to be copied around can become huge!</p>

<p>A second problem is this. When we define a <code>struct</code>, it is always a fixed size. It has a limited number of fields, and each of these fields must be a type which itself is limited in size. If I want to call a function with just <em>a list of integers</em>, where the number of integers I want to pass varys, I clearly can't use a <code>struct</code> to do this.</p>

<p>To get around these issues the developers of C (or y'know...someone) came up with a clever idea. They visualized computer memory as a single huge list of bytes. In this list each byte can be given a global index or position in this list (the first byte is 0, the second is 1, etc).</p>

<p>In this case, all the data in the computer data, including the structures and variables used in the currently running program, start at some index in this huge list. If, rather than copying the data itself to a function, one instead copies a number representing the <em>index</em> at where this data starts, any data of varying size can essentially be passed around.</p>

<p>By using <em>addresses</em> instead of the actual data, one can allow a function to access and modify some location in memory without having to make a copy of it. Functions can also use pointers to do other cool stuff, like output data to some passed in address.</p>

<p>Because the total size of computer memory is fixed, the number of bytes needed to represent an address always the same. But if we keep track of it, the number of bytes the address points to can grown and shrink over time. This means one can create a variable sized data-structure and still sort of <em>pass</em> it to a function, which can inspect and modify it.</p>

<p>So a pointer is just a number. A number representing the starting index of some data in memory. The type of the pointer hints to us, and the compiler, how much data might be in this location.</p>

<p>We can declare pointer types by suffixing existing ones with the the <code>*</code> character. An example of this we've seen already is <code>mpc_parser_t*</code> or <code>mpc_ast_t*</code>.</p>

<p>To create a pointer to some data we have already, we need to get an index, or <em>address</em>. To get the address of a some data we use the <code>&amp;</code> operator. Again you&#39;ve seen this before when we passed in a pointer to <code>mpc_parse</code> so it would output into our <code>mpc_result_t</code>.</p>

<p>Finally we can get the data at an address, called <em>dereferencing</em> using <code>*</code> on the left hand size of a variable. Or we can get the data at the field of a pointer to a struct using an arrow <code>-&gt;</code>, as seen in chapter 7.</p>


<h2>The Stack &amp; The Heap</h2>

<p>I said that memory can be visualized of as one long list of bytes. Actually it is better to imagine it split into two sections. These sections are called <em>The Stack</em> and <em>The Heap</em>.</p>

<p>Some of you may have heard tales of these mysterious locations, such as <em>"the stack grows down but the heap grows up"</em>, or <em>"there can be many stacks, but only one heap"</em>. Ignore this gossip spread by Perl and Java programmers. In C there is no such mythology. The stack and the heap are common as mud, and you will learn to know them well.</p>

<h3>The Stack</h3>

<div class='pull-right alert alert-warning' style="margin: 15px; text-align: center;">
  <img src="/static/img/building.png" alt="building"/>
  <p><small>The Stack &bull; Like what you do with bricks.</small></p>
</div>

<p>The Stack is the memory where your program lives. It is where all of your temporary variables and data structures exist as you manipulate and edit them. Each time you call a function a new area of the stack is put aside for it to use. Into this area are put copies of any arguments passed to the function, as well as some bookkeeping data such as who the caller was, and what to do when finished. When the function is done the area it used is unallocated, ready for use again by someone else.</p>

<p>I like to think of the stack as a building site. Each time we need to do something new we corner of a section of space, enough for our tools and materials, and set to work. We can still go to other parts of the site, or go off-site, if we need certain things, but all our work is done in this section. Once we are done we some task, take what we&#39;ve constructed to a new place and deconstruct that section of the space we've been using.</p>

<h3>The Heap</h3>

<div class='pull-right alert alert-warning' style="margin: 15px; text-align: center;">
  <img src="/static/img/storage.png" alt="storage"/>
  <p><small>The Heap &bull; U LOCK. KEEP KEY.</small></p>
</div>

<p>The Heap is a section of memory put aside for storage of objects with a longer lifespan. Memory in this area has to be manually allocated and deallocated. To allocate new memory the <code>malloc</code> function is used. This function takes as input the number of bytes required, and returns back a pointer to a new block of memory with that many bytes set aside.</p>

<p>When done with the memory at that location it must be released again. To do this the pointer recieved from <code>malloc</code> should be passed to the <code>free</code> function.</p>

<p>Using the Heap is trickier than the Stack because it requires the programmer to remember to call <code>free</code> and to call it correctly. If he or she doesn't, the program may continuously allocate more and more memory. This is called a <em>memory leak</em>. A easy rule to avoid this is to ensure for each <code>malloc</code> there is a corrisponding (and only one corrisponding) <code>free</code>. If this can always be ensured the program should be handling The Heap correctly.</p>

<p>I Imagine the Heap like a huge U-Store-It. We can call up the reception with <code>malloc</code> and request a number of boxes. With these boxes we can do what we want, and we know they will persist no matter how messy the building site gets. We can take things to and from the U-Store-It and the building site. It is useful to store materials and large objects which we only need to retrieve once in a while. The only problem is we need to remember to call the receptionist again with <code>free</code> when we are done. Otherwise soon we&#39;ll have requested all the boxes and run up a big bill.</p>

<p>That was a lot to take in. Have a pause to think about what we've just covered.</p>


<h2>Adding Features</h2>

<p>You'll notice in the following chapters that adding new features to our language usually consists of a number of steps.</p>

<table class='table'>
  <tr><td><strong>Step 1</strong></td><td>Add any new syntax for this data type to the <code>mpc</code> language grammar.</td></tr>
  <tr><td><strong>Step 0</strong></td><td>Add a new type of possible data to the <code>lval</code> struct.</td></tr>
  <tr><td><strong>Step 2</strong></td><td>Add new functions for reading in this data type from the <em>abstract syntax tree</em>.</td></tr>
  <tr><td><strong>Step 3</strong></td><td>Add new functions for evaluating and manipulating this data type.</td></tr>
</table>

<p>This is exactly what we're going to do now for our new <em>list</em> data types.</p>


<h2>Parsing Expressions</h2>

<p>The syntax for S-Expressions and Q-Expressions is really easy. As mentioned before it conists of a number of <code>expr</code> between certain bracket types. We can just add two new basic parse rules and add them as options of the <code>expr</code> rule.</p>

<p>We also change our <code>operator</code> rule to now be <code>symbol</code>. This is because later on we are going to be using variables and other symbols which are not all operators.</p>

<pre><code data-language='c'>  mpc_parser_t* Number = mpc_new(&quot;number&quot;);
  mpc_parser_t* Symbol = mpc_new(&quot;symbol&quot;);
  mpc_parser_t* Sexpr  = mpc_new(&quot;sexpr&quot;);
  mpc_parser_t* Qexpr  = mpc_new(&quot;qexpr&quot;);
  mpc_parser_t* Expr   = mpc_new(&quot;expr&quot;);
  mpc_parser_t* Lispy  = mpc_new(&quot;lispy&quot;);

  mpca_lang(
    &quot;                                                     \
      number : /-?[0-9]+/ ;                               \
      symbol : &#39;+&#39; | &#39;-&#39; | &#39;*&#39; | &#39;/&#39; ;                    \
      sexpr  : &#39;(&#39; &lt;expr&gt;* &#39;)&#39; ;                          \
      qexpr  : &#39;{&#39; &lt;expr&gt;* &#39;}&#39; ;                          \
      expr   : &lt;number&gt; | &lt;symbol&gt; | &lt;sexpr&gt; | &lt;qexpr&gt; ;  \
      lispy  : /^/ &lt;expr&gt;* /$/ ;                          \
    &quot;,
    Number, Symbol, Sexpr, Qexpr, Expr, Lispy);</code></pre>

<p>We should also remember to cleanup these rules on exit.</p>

<pre><code data-language='c'>mpc_cleanup(6, Number, Symbol, Sexpr, Qexpr, Expr, Lispy);</code></pre>


<h2>Expression Structure</h2>

<p>We can now parse lists of expressions, but we still need to store them internally as an <code>lval</code>. We're therefore going to add three new types to the <code>type</code> enum we were using to encode <code>lval</code> types. The first new type is <em>symbol</em>, which we're going to use to represent operators such as <code>+</code>, and later on variables and functions. The other two new types are for <em>S-Expressions</em> and <em>Q-Expressions</em>.</p>

<pre><code data-language='c'>/* Add SYM, SEXPR, and QEXPR as possible lval types. */
enum { LVAL_ERR, LVAL_NUM, LVAL_SYM, LVAL_SEXPR, LVAL_QEXPR };
</code></pre>

<p>We can represent a symbol using just a string. Expressions, on the other hand, are variable length <em>lists</em> of other expressions (which we are themselves <code>lval</code>). As we learnt at the beginning of this chapter we can't create variable length structures, which means we are going to need to use a pointer. At the location pointed to by this pointer we are going to store a list of <code>lval*</code> (pointers to the other <code>lval</code>). Therefore our field should be a double pointer type <code>lval**</code>. This is read as a <em>pointer to pointers</em>.</p>

<p>We will also need to keep track of how many <code>lval*</code> are in this list, so we add an extra field in the <code>lval</code> struct called <code>count</code> to record this.</p> 

<p>Finally we also change the data representing an <em>error</em> from an <code>int</code> to a string. This means we can store a unique error message rather than just an error code. This will make our error reporting better and more flexible, and we can get rid of the original error <code>enum</code>.</p>

<pre><code data-language='c'>
typedef struct lval {
  int type;

  long num;

  /* Error and Symbol types have some string data */
  char* err;
  char* sym;

  /* Record Number of other &quot;lvals&quot; references and a pointer to a list of &quot;lval&quot; pointers */
  int count;
  struct lval** cell;

} lval;</code></pre>


<h2>Constructors &amp; Destructors</h2>

<p>Now when we build an <code>lval</code> it may contain pointers to other things. This means we need to be careful. Whenever we are done with this <code>lval</code> we will also need to delete the things it points to.</p>

<p>One way to make this easier is to only pass around <code>lval*</code>. Then we can make a rule to ourselves. Whenever we free the memory allocated for an <code>lval</code>, we also free all the things it points to.</p>

<p>We can change our <code>lval</code> construction functions to return pointers to an <code>lval</code>, rather than one directly. For this we need to use <code>malloc</code> to allocate enough space for the <code>lval</code> struct, and then to fill in the fields with the relevant information. Using this arrow operator <code>-&gt;</code> this doesn't require too many changes.</p>

<pre><code data-language='c'>/* Construct a pointer to a new Number lval */ 
lval* lval_num(long x) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_NUM;
  v-&gt;num = x;
  return v;
}

/* Construct a pointer to a new Error lval */ 
lval* lval_err(char* m) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_ERR;
  v-&gt;err = malloc(strlen(m) + 1);
  strcpy(v-&gt;err, m);
  return v;
}

/* Construct a pointer to a new Symbol lval */ 
lval* lval_sym(char* s) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_SYM;
  v-&gt;sym = malloc(strlen(s) + 1);
  strcpy(v-&gt;sym, s);
  return v;
}

/* A pointer to a new empty Sexpr lval */
lval* lval_sexpr(void) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_SEXPR;
  v-&gt;count = 0;
  v-&gt;cell = NULL;
  return v;
}

/* A pointer to a new empty Qexpr lval */
lval* lval_qexpr(void) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_QEXPR;
  v-&gt;count = 0;
  v-&gt;cell = NULL;
  return v;
}</code></pre>


<div class="alert alert-warning">
  <p><strong>Why are you using <code>strlen(s) + 1</code>?</strong></p>

  <p>In C strings are <em>null terminated</em>. This means that the final character of them is always the zero character (<code>NULL</code> or <code>\0</code>). This is a convention in C to signal the end of a string. It is important that all strings are stored this way otherwise programs will break in nasty ways.</p>
  
  <p>The <code>strlen</code> function only returns the number of bytes in a string <em>excluding</em> the null terminator. This is why we need to add one, to ensure there is enough allocated space for it all!</p>
</div>

<p>We now need a special function to delete <code>lval*</code>. This should call <code>free</code> on the pointer itself to release the memory gained from <code>malloc</code>, but more importantly it should inspect the type of the <code>lval</code>, and release any memory pointed to by its fields. If we use <code>lval_del</code> for every <code>lval*</code> allocated with our above construction functions we can ensure we will get no memory leaks.</p>

<pre><code class="lang-c">void lval_del(lval* v) {

  switch (v-&gt;type) {
    /* Do nothing special for number type */
    case LVAL_NUM: break;

    /* For Err or Sym free the string data */
    case LVAL_ERR: free(v-&gt;err); break;
    case LVAL_SYM: free(v-&gt;sym); break;

    /* If Qexpr or Sexpr then delete all elements inside */
    case LVAL_QEXPR:
    case LVAL_SEXPR:
      for (int i = 0; i &lt; v-&gt;count; i++) {
        lval_del(v-&gt;cell[i]);
      }
      /* Also free the memory allocated to contain the pointers */
      free(v-&gt;cell);
    break;
  }

  /* Finally free the memory allocated for the &quot;lval&quot; struct itself */
  free(v);
}</code></pre>
    
    
<h2>Reading Expressions</h2>

<p>We are going to use these Expression <code>lval</code> to represet our whole program. First we are going to <em>read</em> in the program and construct an <code>lval*</code> that represents it all. Then we are going to <em>evaluate</em> this Expression to get the result of our program. This first stage should convert the <em>abstract syntax tree</em> into an S-Expression, and the second stage should evaluate this S-Expression using our normal lisp rules.</p>

<p>The first stage is fairly straight-forward. We can recursively parse each node of the tree, and construct different <code>lval</code> types depending on the <code>tag</code> and <code>contents</code> fields of the node.</p>

<p>If the given node is a <code>number</code> or <code>symbol</code>, then it returns an <code>lval*</code> for those types. If it is the <code>root</code>, an <code>sexpr</code> or a <code>qexpr</code>, then it creates an empty S-Expression and slowly adds each valid sub-expression contained in the tree.</p>

<p>We look at each child of the tree and append it to the <code>lval*</code> using a new function <code>lval_add</code>.

<p>The <code>lval_add</code> function increases the count of the Expression list by one, and then uses <code>realloc</code> to reallocate the amount of space required by <code>v-&gt;cell</code>. This new space can be used to store the extra <code>lval*</code> required. Finally it sets the final value of the list with <code>v-&gt;cell[v-&gt;count-1]</code> to the value <code>lval* x</code> passed in. It returns the newly modified <code>lval*</code>.</p>

<pre><code class="lang-c">lval* lval_add(lval* v, lval* x) {
  v-&gt;count++;
  v-&gt;cell = realloc(v-&gt;cell, sizeof(lval*) * v-&gt;count);
  v-&gt;cell[v-&gt;count-1] = x;
  return v;
}

lval* lval_read_num(mpc_ast_t* t) {
  long x = strtol(t-&gt;contents, NULL, 10);
  return errno != ERANGE ? lval_num(x) : lval_err(&quot;invalid number&quot;);
}

lval* lval_read(mpc_ast_t* t) {

  /* If Symbol or Number return conversion to that type */
  if (strstr(t-&gt;tag, &quot;number&quot;)) { return lval_read_num(t); }
  if (strstr(t-&gt;tag, &quot;symbol&quot;)) { return lval_sym(t-&gt;contents); }

  /* If root (&gt;), sexpr or qexpr then create empty list */
  lval* x = NULL;
  if (strcmp(t-&gt;tag, &quot;&gt;&quot;) == 0) { x = lval_sexpr(); } 
  if (strstr(t-&gt;tag, &quot;sexpr&quot;))  { x = lval_sexpr(); }
  if (strstr(t-&gt;tag, &quot;qexpr&quot;))  { x = lval_qexpr(); }

  /* Fill this list with any valid expression contained within */
  for (int i = 0; i &lt; t-&gt;children_num; i++) {
    if (strcmp(t-&gt;children[i]-&gt;contents, &quot;(&quot;) == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;contents, &quot;)&quot;) == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;contents, &quot;}&quot;) == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;contents, &quot;{&quot;) == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;tag,  &quot;regex&quot;) == 0) { continue; }
    x = lval_add(x, lval_read(t-&gt;children[i]));
  }

  return x;
}</code></pre>


<h2>Printing Expressions</h2>

<p>Great! We are so close to trying out all of our new changes. To do this we should modify our print function to take <code>lval*</code> and to be able to print our new expression types. Then we can see how the <em>reading</em> phase works by printing out the resulting S-Expression.</p>

<p>To print out S-Expressions or Q-Expressions we can create another function that loops over all the sub-expressions of an expression and prints these individually separated by spaces. If we make the type of brackets this function uses a parameter we can use it for S-Expression and Q-Expression types.</p>

<pre><code class="lang-c">void lval_print(lval* v);

void lval_expr_print(lval* v, char open, char close) {
  putchar(open);
  for (int i = 0; i &lt; v-&gt;count; i++) {

    /* Print Value contained within */
    lval_print(v-&gt;cell[i]);

    /* Don&#39;t print trailing space if last element */
    if (i != (v-&gt;count-1)) {
      putchar(&#39; &#39;);
    }
  }
  putchar(close);
}

void lval_print(lval* v) {
  switch (v-&gt;type) {
    case LVAL_NUM:   printf(&quot;%li&quot;, v-&gt;num); break;
    case LVAL_ERR:   printf(&quot;Error: %s&quot;, v-&gt;err); break;
    case LVAL_SYM:   printf(&quot;%s&quot;, v-&gt;sym); break;
    case LVAL_SEXPR: lval_expr_print(v, &#39;(&#39;, &#39;)&#39;); break;
    case LVAL_QEXPR: lval_expr_print(v, &#39;{&#39;, &#39;}&#39;); break;
  }
}

void lval_println(lval* v) { lval_print(v); putchar(&#39;\n&#39;); }</code></pre>

<p>In our main loop, instead of evaluation, we can try reading in the result and printing out what we have read.</p>

<pre><code data-language='c'>lval* x = lval_read(r.output);
lval_println(x);
lval_del(x);</code></pre>

<p>If this is successful you should see something like the following when entering input to your program.</p>

<pre><code data-language='lispy'>lispy&gt; + 2 2
(+ 2 2)
lispy&gt; + 2 (* 7 6) (* 2 5)
(+ 2 (* 7 6) (* 2 5))
lispy&gt; *     55     101  (+ 0 0 0)
(* 55 101 (+ 0 0 0))
lispy&gt;</code></pre>


<h2>Evaluating Expressions</h2>

<p>The main change to our evaluation function is that as input it must take some <code>lval*</code>, and must return some <code>lval*</code>. We can think of our evaluation function as a kind of transformer. It takes in some <code>lval*</code> and transforms it in some way to some new <code>lval*</code>. In some cases it can just return exactly the same thing. In other cases it may modify the input <code>lval*</code> and the return it. In many cases it will delete the input, and return something completely different. If this is the case we must always remember to delete the input <code>lval*</code> when we are going to return something new.</p>

<p>Our evaluation of all types other than S-Expressions is to return them directly.</p>

<p>For S-Expressions we first evaluate all the children of the S-Expression. If any of these children are Errors we return the first error we encounter using a function we'll define later called <code>lval_take</code>.</p>

<p>We then check for the empty expression. If the expression has no children we just return it directly. This corrisponds to the construct <code>()</code>. We also check for the single expression. This is an expression with only one child such as <code>(5)</code>. This is also returned directly. If neither of these are the case we know we have a valid expression with more than one child.</p>

<p>We extract the first element of the expression using a function we'll define later called <code>lval_pop</code>. We need to check this is a <em>symbol</em> and not a <em>number</em> or an <em>Q-Expression</em>. If it is a symbol we check what symbol it is and find a result using <code>builtin_op</code>, otherwise we delete the first element and the values passed into the evaluation function, and return an error.</p>

<pre><code class="lang-c">lval* lval_eval_sexpr(lval* v) {

  /* Evaluate Children */
  for (int i = 0; i &lt; v-&gt;count; i++) {
    v-&gt;cell[i] = lval_eval(v-&gt;cell[i]);
  }

  /* Error Checking */
  for (int i = 0; i &lt; v-&gt;count; i++) {
    if (v-&gt;cell[i]-&gt;type == LVAL_ERR) { return lval_take(v, i); }
  }

  /* Empty Expression */
  if (v-&gt;count == 0) { return v; }

  /* Single Expression */
  if (v-&gt;count == 1) { return lval_take(v, 0); }

  /* Ensure First Element is Symbol Start */
  lval* f = lval_pop(v, 0);
  if (f-&gt;type != LVAL_SYM) {
    lval_del(f); lval_del(v);
    return lval_err(&quot;S-expression Does not start with symbol!&quot;);
  }

  /* Call builtin with operator */
  lval* result = builtin_op(v, f-&gt;sym);
  lval_del(f);
  return result;
}

lval* lval_eval(lval* v) {
  /* Evaluate Sexpressions */
  if (v-&gt;type == LVAL_SEXPR) { return lval_eval_sexpr(v); }
  /* All other lval types remain the same */
  return v;
}</code></pre>

<p>There are two functions we use in the above code called <code>lval_pop</code> and <code>lval_take</code>.</p>

<p>The <code>lval_pop</code> function extracts a single element from an Expression at index <code>i</code> and shifts the rest of the list backward so that it no longer contains that <code>lval*</code>. It then returns the extracted value. Notice that it doesn't delete the input list. It is like taking an element from a list and separating it out. This means both the element popped and the old list need to be deleted at some point with <code>lval_del</code>.</p>

<p>The <code>lval_take</code> function is similar to <code>lval_pop</code> but it deletes the list it has extracted the item from. This is like taking an item from the list and deleting the rest. It is a slight variation on <code>lval_pop</code> but it makes our code easier to read in some places.</p>

<pre><code class="lang-c">lval* lval_pop(lval* v, int i) {
  /* Find the item at &quot;i&quot; */
  lval* x = v-&gt;cell[i];

  /* Shift the memory following the item at &quot;i&quot; over the top of it */
  memmove(&amp;v-&gt;cell[i], &amp;v-&gt;cell[i+1], sizeof(lval*) * (v-&gt;count-i-1));

  /* Decrease the count of items in the list */
  v-&gt;count--;

  /* Reallocate the memory used */
  v-&gt;cell = realloc(v-&gt;cell, sizeof(lval*) * v-&gt;count);
  return x;
}

lval* lval_take(lval* v, int i) {
  lval* x = lval_pop(v, i);
  lval_del(v);
  return x;
}</code></pre>

<p>Now we need to define the <code>builtin_op</code> function. This is like the function used in our previous chapter but modified to take an <code>lval*</code> which represents a list of all the <code>lval*</code> to operate on. It also needs to do some more rigirous error checking. If any of the inputs are a non-number <code>lval*</code> we need to return an error.</p>

<p>So first it checks that all the sub-expression in the input are numbers. It then pops the first sub-expression as a starting point. If there are no more sub-expressions and the operator is subtraction it performs unary negation. This makes expressions such as <code>(- 5)</code> evaluate correctly.</p>

<p>Then it constantly pops the next sub-expression from the list and performs arithmatic depending on the operator. If a zero is encountered on division it deletes the temporary <code>lval</code> <code>x</code>, <code>y</code>, and the argument list <code>a</code>, and returns an error.</p>

<p>Finally if there have been no errors the input arguments are deleted and the new expression returned.</p>

<pre><code class="lang-c">lval* builtin_op(lval* a, char* op) {
  
  /* Ensure all arguments are numbers */
  for (int i = 0; i < a->count; i++) {
    if (a&gt;cell[i]-&gt;type != LVAL_NUM) {
      lval_del(a);
      return lval_err(&quot;Cannot operator on non number!&quot;);
    }
  }
  
  /* Pop the first element */
  lval* x = lval_pop(a, 0);

  /* If no arguments and sub then perform unary negation */
  if ((strcmp(op, &quot;-&quot;) == 0) &amp;&amp; a-&gt;count == 0) { x-&gt;num = -x-&gt;num; }

  /* While there are still elements remaining */
  while (a-&gt;count &gt; 0) {

    /* Pop the next element */
    lval* y = lval_pop(a, 0);

    /* Perform operation */
    if (strcmp(op, &quot;+&quot;) == 0) { x-&gt;num += y-&gt;num; }
    if (strcmp(op, &quot;-&quot;) == 0) { x-&gt;num -= y-&gt;num; }
    if (strcmp(op, &quot;*&quot;) == 0) { x-&gt;num *= y-&gt;num; }
    if (strcmp(op, &quot;/&quot;) == 0) {
      if (y-&gt;num == 0) {
        lval_del(x); lval_del(y); lval_del(a);
        x = lval_err(&quot;Division By Zero!&quot;); break;
      } else {
        x-&gt;num /= y-&gt;num;
      }
    }

    /* Delete element now finished with */
    lval_del(y);
  }

  /* Delete input expression and return result */
  lval_del(a);
  return x;
}</code></pre>

<p>Our evalation functions are complete! We just need to change <code>main</code> again to pass the input through evaluation and print out the result.</p>

<pre><code data-language='c'>lval* x = lval_eval(lval_read(r.output));
lval_println(x);
lval_del(x);
</code></pre>

<p>If all this is successful then you should now be able to evaluate expressions correctly in the same way as in the previous chapter. Take a little breather and have a play around with the new evaluation. Make sure everything is working and sane.</p>

<pre><code data-language='lispy'>lispy&gt; + 1 2 3
6
lispy&gt; + 1 (* 7 5) 3
39
lispy&gt; (- 100)
-100
lispy&gt; 
()
lispy&gt; / 6 {5 6}
Error: Cannot operator on non number!</code></pre>


<h2>Builtin Functions</h2>

<p>We&#39;ve got all the ground work in place, but our Q-Expression type is still useless. There is no way to manipulate it. It can be parsed in, but just throws an error whenever we operate on it.</p>

<p>We need to add some builtin operations much like <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>, but to work on our list type. Choosing a consise set of these is important. If we implement a few fundamental operations then we can use these to define new operations without changing any C code. Actually we can achieve all we wish to do with lists using just 5 operations on lists. Here are what I've called them, and their indended behaviour.

<table class='table'>
  <tr><td><code>list</code></td><td>Takes one or more Expressions and returns a new Q-Expression containing them</td></tr>
  <tr><td><code>head</code></td><td>Takes a Q-Expression and returns a Q-Expression consisting only of the first element</td></tr>
  <tr><td><code>tail</code></td><td>Takes a Q-Expression and returns a Q-Expression without the first element of the original</td></tr>
  <tr><td><code>join</code></td><td>Takes one or more Q-Expressions and return a Q-Expression of them conjoined together</td></tr>
  <tr><td><code>eval</code></td><td>Takes a Q-Expression and evaluates it as if it were a S-Expression</td></tr>
</table>

<p>Like with our operators we should add these functions as possible valid symbols.</p>

<pre><code class="lang-c">mpca_lang(
  &quot;                                                                                         \
    number : /-?[0-9]+/ ;                                                                   \
    symbol : \&quot;list\&quot; | \&quot;head\&quot; | \&quot;tail\&quot; | \&quot;join\&quot; | \&quot;eval\&quot; | &#39;+&#39; | &#39;-&#39; | &#39;*&#39; | &#39;/&#39; ; \
    sexpr  : &#39;(&#39; &lt;expr&gt;* &#39;)&#39; ;                                                              \
    qexpr  : &#39;{&#39; &lt;expr&gt;* &#39;}&#39; ;                                                              \
    expr   : &lt;number&gt; | &lt;symbol&gt; | &lt;sexpr&gt; | &lt;qexpr&gt; ;                                      \
    lispy  : /^/ &lt;expr&gt;* /$/ ;                                                              \
  &quot;,
  Number, Symbol, Sexpr, Qexpr, Expr, Lispy)</code></pre>

  
<p>Now, like our operators, we can set about writing them as functions...</p>

  
<h2>First Attempt</h2>

<p>The actual task of taking the head or tail of an Q-Expression shouldn't be too hard for us using some already existing functions we've defined. But we also need to check for errors. There are a number of conditions that are bad for the <code>head</code> and <code>tail</code> functions. First of all we must ensure they are only passed a single argument, and that that argument is a Q-Expression.</p>

<p>Then we need to ensure that this Q-Expression isn't empty and actually has some sub-expressions.</p>

<p>Once we've checked for errors in the <code>head</code> function we can take the first argument and repeatedly pop and delete the item at index <code>1</code> until there is only one item left in the list. In the <code>tail</code> function we can just pop the item at index <code>0</code> and delete it. An initial attempt might look like this.</p>

<pre><code class="lang-c">lval* builtin_head(lval* a) {
  /* Check Error Conditions */
  if (a-&gt;count != 1) { lval_del(a); return lval_err(&quot;Function &#39;head&#39; passed too many arguments!&quot;); }
  if (a-&gt;cell[0]-&gt;type != LVAL_QEXPR) { lval_del(a); return lval_err(&quot;Function &#39;head&#39; passed incorrect types!&quot;); }
  if (a-&gt;cell[0]-&gt;count == 0) { lval_del(a); return lval_err(&quot;Function &#39;head&#39; passed {}!&quot;); }

  /* Otherwise take first argument */
  lval* v = lval_take(a, 0);

  /* Delete all elements that are not head and return */
  while (v-&gt;count &gt; 1) { lval_del(lval_pop(v, 1)); }
  return v;
}

lval* builtin_tail(lval* a) {
  /* Check Error Conditions */
  if (a-&gt;count != 1) { lval_del(a); return lval_err(&quot;Function &#39;tail&#39; passed too many arguments!&quot;); }
  if (a-&gt;cell[0]-&gt;type != LVAL_QEXPR) { lval_del(a); return lval_err(&quot;Function &#39;tail&#39; passed incorrect types!&quot;); }  
  if (a-&gt;cell[0]-&gt;count == 0) { lval_del(a); return lval_err(&quot;Function &#39;tail&#39; passed {}!&quot;); }

  /* Take first argument */
  lval* v = lval_take(a, 0);

  /* Delete first element and return */
  lval_del(lval_pop(v, 0));
  return v;
}</code></pre>


<h2>Macros</h2>

<div class='pull-right alert alert-warning' style="margin: 15px; text-align: center;">
  <img src="/static/img/strawberry.png" alt="strawberry"/>
  <p><small>Strawberry &bull; A delicious macro.</small></p>
</div>

<p>This is a bit of a mess - and really hard to read. One way to clean it up is to use a <em>Macro</em>.</p>

<p>A macro is a <em>preprocessor</em> directive that acts like a function that is evaluated before the program is compiled. It can be used for a whole host of different things including our task here - to clean up how some code reads.</p>

<p>What a macro does is take some arguments (which can be almost anything), and copies and pastes them into some given pattern. By changing the pattern we can change what different code is generated by the macro. To define macros we use the <code>#define</code> preprocessor directive. After this directive is given the name of the macro, followed by the argument names in parenthesis. After this the pattern is specified to say what code should be generated for the given arguments.</p>

<p>We can design a macro to help with our error conditions called <code>LASSERT</code>. Macros are typeically given names in all capitals to help distinguish them from normal C functions.</p>

<pre><code class="lang-c">#define LASSERT(args, cond, err) if (!(cond)) { lval_del(args); return lval_err(err); }</code></pre>

<p>This macro take in three arguments <code>args</code>, <code>cond</code> and <code>err</code>. It then generates code as shown on the right hand side, but with these variables pasted in at the locations where they are named.</p>

<h3>Head &amp; Tail</h3>

<p>We can use this to change how our above code is written without actually changing what code is generated at the end of the day. This makes it much easier to read for the programmer, and saves a bit of typing.</p>

<p>Using this our <code>head</code> and <code>tail</code> functions are defined as follows.</p>

<pre><code class="lang-c">lval* builtin_head(lval* a) {
  LASSERT(a, (a-&gt;count == 1                 ), &quot;Function &#39;head&#39; passed too many arguments!&quot;);
  LASSERT(a, (a-&gt;cell[0]-&gt;type == LVAL_QEXPR), &quot;Function &#39;head&#39; passed incorrect type!&quot;);
  LASSERT(a, (a-&gt;cell[0]-&gt;count != 0        ), &quot;Function &#39;head&#39; passed {}!&quot;);

  lval* v = lval_take(a, 0);  
  while (v-&gt;count &gt; 1) { lval_del(lval_pop(v, 1)); }
  return v;
}

lval* builtin_tail(lval* a) {
  LASSERT(a, (a-&gt;count == 1                 ), &quot;Function &#39;tail&#39; passed too many arguments!&quot;);
  LASSERT(a, (a-&gt;cell[0]-&gt;type == LVAL_QEXPR), &quot;Function &#39;tail&#39; passed incorrect type!&quot;);
  LASSERT(a, (a-&gt;cell[0]-&gt;count != 0        ), &quot;Function &#39;tail&#39; passed {}!&quot;);

  lval* v = lval_take(a, 0);  
  lval_del(lval_pop(v, 0));
  return v;
}</code></pre>

<h3>List &amp; Eval</h3>

<p>We can also define our <code>list</code> and <code>eval</code> easily now, accomodating for the various error conditions.</p>

<p>The <code>list</code> function is dead simple. It just converts the input S-Expression to a Q-Expression and returns it.</p>

<p>The <code>eval</code> function is somewhat like the opposite. It takes as input some single Q-Expression, which it should convert to an S-Expression, and evaluate using <code>lval_eval</code>.</p>

<pre><code data-language='c'>lval* builtin_list(lval* a) {
  a-&gt;type = LVAL_QEXPR;
  return a;
}

lval* builtin_eval(lval* a) {
  LASSERT(a, (a-&gt;count == 1                 ), &quot;Function &#39;eval&#39; passed too many arguments!&quot;);
  LASSERT(a, (a-&gt;cell[0]-&gt;type == LVAL_QEXPR), &quot;Function &#39;eval&#39; passed incorrect type!&quot;);

  lval* x = lval_take(a, 0);
  x-&gt;type = LVAL_SEXPR;
  return lval_eval(x);
}</code></pre>

<h3>Join</h3>

<p>The <code>join</code> function is our final one to define. Because it can work on one or more arguments its structure looks somewhat like that of <code>builtin_op</code>.</p>

<p>First we check that all of the arguments are Q-Expressions and then we join them together one-by-one. To do this we use the function <code>lval_join</code>. This works by repeatedly popping each item from <code>y</code> and adding it to <code>x</code> until <code>y</code> is empty. It then deletes <code>y</code> and returns <code>x</code>.</p>

<pre><code class="lang-c">lval* builtin_join(lval* a) {

  for (int i = 0; i &lt; a-&gt;count; i++) {
    LASSERT(a, (a-&gt;cell[i]-&gt;type == LVAL_QEXPR), "Function 'join' passed incorrect type.");
  }

  lval* x = lval_pop(a, 0);

  while (a-&gt;count) {
    x = lval_join(x, lval_pop(a, 0));
  }

  lval_del(a);
  return x;
}

lval* lval_join(lval* x, lval* y) {

  /* For each cell in 'y' add it to 'x' */
  while (y-&gt;count) {
    x = lval_add(x, lval_pop(y, 0));
  }

  /* Delete the empty 'y' and return 'x' */
  lval_del(y);  
  return x;
}</code></pre>


<h2>Builtins Lookup</h2>

<p>We have all of our builtin functions so now we need to make a function that can call the correct one depending on what symbol it encounters. We can do this using <code>strcmp</code> and <code>strstr</code>.</p>

<pre><code data-language='c'>lval* builtin(lval* a, char* func) {
  if (strcmp(&quot;list&quot;, func) == 0) { return builtin_list(a); }
  if (strcmp(&quot;head&quot;, func) == 0) { return builtin_head(a); }
  if (strcmp(&quot;tail&quot;, func) == 0) { return builtin_tail(a); }
  if (strcmp(&quot;join&quot;, func) == 0) { return builtin_join(a); }
  if (strcmp(&quot;eval&quot;, func) == 0) { return builtin_eval(a); }
  if (strstr(&quot;+-/*&quot;, func)) { return builtin_op(a, func); }
  lval_del(a);
  return lval_err(&quot;Unknown Function!&quot;);
}</code></pre>

<p>Then we can change our evaluation line in <code>lval_eval_sexpr</code> to call <code>builtin</code> rather than <code>builtin_op</code>.</p>

<pre><code data-language='c'>/* Call builtin with operator */
lval* result = builtin(v, func-&gt;sym);
lval_del(func);
return result;</code></pre>

<p>Now lists should now be supported in our language! Compile and run the latest version and see what you can do with the new list operators. Try putting code and symbols into our lists and evaluating them in different ways. The ability to put S-Expressions inside a list using Q-Expressions is pretty awesome. It means we can treat code like data itself. We can't even do this in C!</p>

<pre><code data-language='lispy'>lispy&gt; list 1 2 3 4
{1 2 3 4}
lispy&gt; {head (list 1 2 3 4)}
{head (list 1 2 3 4)}
lispy&gt; eval {head (list 1 2 3 4)}
{1}
lispy&gt; tail {tail tail tail}
{tail tail}
lispy&gt; eval (tail {tail tail {5 6 7}})
{6 7}
lispy&gt; eval (head {(+ 1 2) (+ 10 20)})
3</code></pre>


<h2>Tutorial Code</h2>

<div class="panel-group alert alert-warning" id="accordion">
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne">
          into_lisp.c
        </a>
      </h4>
    </div>
    <div id="collapseOne" class="panel-collapse collapse">
      <div class="panel-body">
<pre><code data-language='c'>#include "mpc.h"

#ifdef _WIN32

static char input[2048];

char* readline(char* prompt) {
  
  fputs("lispy&gt; ", stdout);
  fgets(input, 2047, stdin);
    
  char* cpy = malloc(strlen(input)+1);
  strcpy(cpy, input);
  cpy[strlen(cpy)] = '\0';
  
  return cpy;
}

void add_history(char* unused) {}

#else

#include &lt;editline/readline.h&gt;
#include &lt;editline/history.h&gt;

#endif

/* Add SYM, SEXPR, and QEXPR as possible lval types */
enum { LVAL_ERR, LVAL_NUM, LVAL_SYM, LVAL_SEXPR, LVAL_QEXPR };

typedef struct lval {
  int type;

  long num;
  
  /* Error and Symbol types have some string data */
  char* err;
  char* sym;
  
  /* Record Number of other `lvals` references and a pointer to a list of `lval` pointers */
  int count;
  struct lval** cell;
  
} lval;

/* Construct a pointer to a new Number lval */ 
lval* lval_num(long x) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_NUM;
  v-&gt;num = x;
  return v;
}

/* Construct a pointer to a new Error lval */ 
lval* lval_err(char* m) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_ERR;
  v-&gt;err = malloc(strlen(m) + 1);
  strcpy(v-&gt;err, m);
  return v;
}

/* Construct a pointer to a new Symbol lval */ 
lval* lval_sym(char* s) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_SYM;
  v-&gt;sym = malloc(strlen(s) + 1);
  strcpy(v-&gt;sym, s);
  return v;
}

/* A pointer to a new empty Sexpr lval */
lval* lval_sexpr(void) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_SEXPR;
  v-&gt;count = 0;
  v-&gt;cell = NULL;
  return v;
}

/* A pointer to a new empty Qexpr lval */
lval* lval_qexpr(void) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_QEXPR;
  v-&gt;count = 0;
  v-&gt;cell = NULL;
  return v;
}

void lval_del(lval* v) {

  switch (v-&gt;type) {
    /* Do nothing special for number type */
    case LVAL_NUM: break;
    
    /* For Err or Sym free the string data */
    case LVAL_ERR: free(v-&gt;err); break;
    case LVAL_SYM: free(v-&gt;sym); break;
    
    /* If Qexpr or Sexpr then delete all elements inside */
    case LVAL_QEXPR:
    case LVAL_SEXPR:
      for (int i = 0; i &lt; v-&gt;count; i++) {
        lval_del(v-&gt;cell[i]);
      }
      /* Also free the memory allocated to contain the pointers */
      free(v-&gt;cell);
    break;
  }
  
  /* Finally free the memory allocated for the "lval" struct itself */
  free(v);
}

lval* lval_add(lval* v, lval* x) {
  v-&gt;count++;
  v-&gt;cell = realloc(v-&gt;cell, sizeof(lval*) * v-&gt;count);
  v-&gt;cell[v-&gt;count-1] = x;
  return v;
}

lval* lval_pop(lval* v, int i) {
  /* Find the item at "i" */
  lval* x = v-&gt;cell[i];
  
  /* Shift the memory following the item at "i" over the top of it */
  memmove(&v-&gt;cell[i], &v-&gt;cell[i+1], sizeof(lval*) * (v-&gt;count-i-1));
  
  /* Decrease the count of items in the list */
  v-&gt;count--;
  
  /* Reallocate the memory used */
  v-&gt;cell = realloc(v-&gt;cell, sizeof(lval*) * v-&gt;count);
  return x;
}

lval* lval_join(lval* x, lval* y) {

  /* For each cell in 'y' add it to 'x' */
  while (y-&gt;count) {
    x = lval_add(x, lval_pop(y, 0));
  }

  /* Delete the empty 'y' and return 'x' */
  lval_del(y);  
  return x;
}

lval* lval_take(lval* v, int i) {
  lval* x = lval_pop(v, i);
  lval_del(v);
  return x;
}

void lval_print(lval* v);

void lval_expr_print(lval* v, char open, char close) {
  putchar(open);
  for (int i = 0; i &lt; v-&gt;count; i++) {
    
    /* Print Value contained within */
    lval_print(v-&gt;cell[i]);
    
    /* Don't print trailing space if last element */
    if (i != (v-&gt;count-1)) {
      putchar(' ');
    }
  }
  putchar(close);
}

void lval_print(lval* v) {
  switch (v-&gt;type) {
    case LVAL_NUM:   printf("%li", v-&gt;num); break;
    case LVAL_ERR:   printf("Error: %s", v-&gt;err); break;
    case LVAL_SYM:   printf("%s", v-&gt;sym); break;
    case LVAL_SEXPR: lval_expr_print(v, '(', ')'); break;
    case LVAL_QEXPR: lval_expr_print(v, '{', '}'); break;
  }
}

void lval_println(lval* v) { lval_print(v); putchar('\n'); }

#define LASSERT(args, cond, err) if (!(cond)) { lval_del(args); return lval_err(err); }
  
lval* lval_eval(lval* v);

lval* builtin_list(lval* a) {
  a-&gt;type = LVAL_QEXPR;
  return a;
}

lval* builtin_head(lval* a) {
  LASSERT(a, (a-&gt;count == 1                 ), "Function 'head' passed too many arguments.");
  LASSERT(a, (a-&gt;cell[0]-&gt;type == LVAL_QEXPR), "Function 'head' passed incorrect type.");
  LASSERT(a, (a-&gt;cell[0]-&gt;count != 0        ), "Function 'head' passed {}.");
  
  lval* v = lval_take(a, 0);  
  while (v-&gt;count &gt; 1) { lval_del(lval_pop(v, 1)); }
  return v;
}

lval* builtin_tail(lval* a) {
  LASSERT(a, (a-&gt;count == 1                 ), "Function 'tail' passed too many arguments.");
  LASSERT(a, (a-&gt;cell[0]-&gt;type == LVAL_QEXPR), "Function 'tail' passed incorrect type.");
  LASSERT(a, (a-&gt;cell[0]-&gt;count != 0        ), "Function 'tail' passed {}.");

  lval* v = lval_take(a, 0);  
  lval_del(lval_pop(v, 0));
  return v;
}

lval* builtin_eval(lval* a) {
  LASSERT(a, (a-&gt;count == 1                 ), "Function 'eval' passed too many arguments.");
  LASSERT(a, (a-&gt;cell[0]-&gt;type == LVAL_QEXPR), "Function 'eval' passed incorrect type.");
  
  lval* x = lval_take(a, 0);
  x-&gt;type = LVAL_SEXPR;
  return lval_eval(x);
}

lval* builtin_join(lval* a) {

  for (int i = 0; i &lt; a-&gt;count; i++) {
    LASSERT(a, (a-&gt;cell[i]-&gt;type == LVAL_QEXPR), "Function 'join' passed incorrect type.");
  }
  
  lval* x = lval_pop(a, 0);
  
  while (a-&gt;count) {
    x = lval_join(x, lval_pop(a, 0));
  }
  
  lval_del(a);
  return x;
}

lval* builtin_op(lval* a, char* op) {
  
  /* Ensure all arguments are numbers */
  for (int i = 0; i &lt; a-&gt;count; i++) {
    if (a-&gt;cell[i]-&gt;type != LVAL_NUM) {
      lval_del(a);
      return lval_err("Cannot operator on non number!");
    }
  }
  
  /* Pop the first element */
  lval* x = lval_pop(a, 0);
  
  /* If no arguments and sub then perform unary negation */
  if ((strcmp(op, "-") == 0) && a-&gt;count == 0) { x-&gt;num = -x-&gt;num; }
  
  /* While there are still elements remaining */
  while (a-&gt;count &gt; 0) {
  
    /* Pop the next element */
    lval* y = lval_pop(a, 0);
    
    /* Perform operation */
    if (strcmp(op, "+") == 0) { x-&gt;num += y-&gt;num; }
    if (strcmp(op, "-") == 0) { x-&gt;num -= y-&gt;num; }
    if (strcmp(op, "*") == 0) { x-&gt;num *= y-&gt;num; }
    if (strcmp(op, "/") == 0) {
      if (y-&gt;num == 0) {
        lval_del(x); lval_del(y); lval_del(a);
        x = lval_err("Division By Zero.");
        break;
      } else {
        x-&gt;num /= y-&gt;num;
      }
    }
    
    /* Delete element now finished with */
    lval_del(y);
  }
  
  /* Delete input expression and return result */
  lval_del(a);
  return x;
}

lval* builtin(lval* a, char* func) {
  if (strcmp("list", func) == 0) { return builtin_list(a); }
  if (strcmp("head", func) == 0) { return builtin_head(a); }
  if (strcmp("tail", func) == 0) { return builtin_tail(a); }
  if (strcmp("join", func) == 0) { return builtin_join(a); }
  if (strcmp("eval", func) == 0) { return builtin_eval(a); }
  if (strstr("+-/*", func)) { return builtin_op(a, func); }
  lval_del(a);
  return lval_err("Unknown Function!");
}

lval* lval_eval_sexpr(lval* v) {
  
  /* Evaluate Children */
  for (int i = 0; i &lt; v-&gt;count; i++) {
    v-&gt;cell[i] = lval_eval(v-&gt;cell[i]);
  }
  
  /* Error Checking */
  for (int i = 0; i &lt; v-&gt;count; i++) {
    if (v-&gt;cell[i]-&gt;type == LVAL_ERR) { return lval_take(v, i); }
  }
  
  /* Empty Expression */
  if (v-&gt;count == 0) { return v; }
  
  /* Single Expression */
  if (v-&gt;count == 1) { return lval_take(v, 0); }
  
  /* Ensure First Element is Symbol Start */
  lval* f = lval_pop(v, 0);
  if (f-&gt;type != LVAL_SYM) {
    lval_del(f); lval_del(v);
    return lval_err("S-expression Does not start with symbol.");
  }
  
  /* Call builtin with operator */
  lval* result = builtin(v, f-&gt;sym);
  lval_del(f);
  return result;
}

lval* lval_eval(lval* v) {
  /* Evaluate Sexpressions */
  if (v-&gt;type == LVAL_SEXPR) { return lval_eval_sexpr(v); }
  /* All other lval types remain the same */
  return v;
}

lval* lval_read_num(mpc_ast_t* t) {
  long x = strtol(t-&gt;contents, NULL, 10);
  return errno != ERANGE ? lval_num(x) : lval_err("invalid number");
}

lval* lval_read(mpc_ast_t* t) {
  
  /* If Symbol or Number return conversion to that type */
  if (strstr(t-&gt;tag, "number")) { return lval_read_num(t); }
  if (strstr(t-&gt;tag, "symbol")) { return lval_sym(t-&gt;contents); }
  
  /* If root (&gt;), sexpr or qexpr then create empty list */
  lval* x = NULL;
  if (strcmp(t-&gt;tag, "&gt;") == 0) { x = lval_sexpr(); } 
  if (strstr(t-&gt;tag, "sexpr"))  { x = lval_sexpr(); }
  if (strstr(t-&gt;tag, "qexpr"))  { x = lval_qexpr(); }
  
  /* Fill this list with any valid expression contained within */
  for (int i = 0; i &lt; t-&gt;children_num; i++) {
    if (strcmp(t-&gt;children[i]-&gt;contents, "(") == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;contents, ")") == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;contents, "}") == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;contents, "{") == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;tag,  "regex") == 0) { continue; }
    x = lval_add(x, lval_read(t-&gt;children[i]));
  }
  
  return x;
}

int main(int argc, char** argv) {
  
  mpc_parser_t* Number = mpc_new("number");
  mpc_parser_t* Symbol = mpc_new("symbol");
  mpc_parser_t* Sexpr  = mpc_new("sexpr");
  mpc_parser_t* Qexpr  = mpc_new("qexpr");
  mpc_parser_t* Expr   = mpc_new("expr");
  mpc_parser_t* Lispy  = mpc_new("lispy");
  
  mpca_lang(
    "                                                                                         \
      number : /-?[0-9]+/ ;                                                                   \
      symbol : \"list\" | \"head\" | \"tail\" | \"eval\" | \"join\" | '+' | '-' | '*' | '/' ; \
      sexpr  : '(' &lt;expr&gt;* ')' ;                                                              \
      qexpr  : '{' &lt;expr&gt;* '}' ;                                                              \
      expr   : &lt;number&gt; | &lt;symbol&gt; | &lt;sexpr&gt; | &lt;qexpr&gt; ;                                      \
      lispy  : /^/ &lt;expr&gt;* /$/ ;                                                              \
    ",
    Number, Symbol, Sexpr, Qexpr, Expr, Lispy);
  
  fputs("Lispy Version 0.0.0.0.4\n", stdout);
  fputs("Press Ctrl+c to Exit\n\n", stdout);
  
  while (1) {
  
    char* input = readline("lispy&gt; ");
    add_history(input);
    
    mpc_result_t r;
    if (mpc_parse("&lt;stdin&gt;", input, Lispy, &r)) {
      

      lval* x = lval_eval(lval_read(r.output));
      lval_println(x);
      lval_del(x);
      
      mpc_ast_delete(r.output);
    } else {    
      mpc_err_print(r.error);
      mpc_err_delete(r.error);
    }
    
    free(input);
    
  }
  
  mpc_cleanup(6, Number, Symbol, Sexpr, Qexpr, Expr, Lispy);
  
  return 0;
}</code></pre>
      </div>
    </div>
  </div>
</div>

<h2>Bonus Marks</h2>

<div class="alert alert-warning">
  <ul class="list-group">
    <li class="list-group-item">&bull; Add a builtin function <code>len</code> that returns the length of a list.</li>
    <li class="list-group-item">&bull; Add a builtin function <code>init</code> that returns all of a list except the final element.</li>
  </ul>
</div>


<h2>Navigation</h2>

<p><a href="chapter10_variables"><strong>Next Chapter &bull; Variables</strong></a></p>

<p><a href="chapter8_error_handling"><strong>Previous Chapter &bull; Error Handling</strong></a></p>