<h1>S-Expressions <small>&bull; Chapter 9</small></h1>


<h2>Lists and Lisps</h2> <hr/>

<p>In the first chapter I mentioned that a Lisp is a language based around lists, but so far we've not seen many of them. In this chapter we rectify that, by finally converting our program into something that could vaguely be called a Lisp. The final result of this chapter wont differ in behaviour from the previous chapter. We are just going to spend time changing how it works internally. This is called <em>refactoring</em> and it will make our life a lot easier later on. Just because we wont have a discernable result at the end doesn't mean we've not done good work. Like preparation for a meal, just because we're not plating up doesn't mean we're not part of the process. Sometimes the anticipation is even better than the food!

<p>In this chapter we'll change our program to convert the <em>abstract syntax tree</em> input into an internal list structure we can store, and then evaluate in a single step.</p>


<h2>Types of list</h2> <hr/>

<p>In our Lisp there are going to be two types of list.</p>

<div class='pull-right alert alert-warning' style="margin: 15px; text-align: center;">
  <img src="/static/img/lisp.png" alt="lisp"/>
  <p><small>ALL CAPS &bull; SO RIGHT YET SO WRONG.</small></p>
</div>

<p>The first we are going to call S-Expressions (standing for <em>symbolic expression</em>). These are what we're going to add in this chapter. They are lists of numbers, symbols, other Expressions that are surrounded in parenthesis <code>()</code>. These are the guys we have used to so far. We will use them to read in and store the actual structure of the program. But most importantly they have the particular evaluation behaviour typical of Lisps. That to evaluate an S-Expression we look at the first item in the list, and take this to be the operator. We then look at all the other items in the list, and take these as operands to get the result.</p>

<p>The second type of list we are going to call Q-Expressions (standing for <em>quoted expression</em>). These are what we're going to add in the next chapter. Again these are lists of numbers, symbols, and other Expressions, but these are going to be put in curly brackets <code>{}</code>. Q-Expressions are used to store lists of things we don&#39;t want to be evaluated. This could be numbers, functions, S-Expressions or anything else. When encountered by the evaluation function Q-Expressions are <em>not</em> evaluated like S-Expressions - they are left exactly as they are. This unique behaviour makes them ideal for a whole number of purposes we will encounter later.</p>

<p>Just using these two types of list, a handful of operators, and a bit of creativity, we can build a programming language that is incredibly powerful and flexible.</p>


<h2>Pointers</h2> <hr/>

<p>In C no concept of lists can be explored without dealing properly with pointers. Pointers are a famously misunderstood aspect of C. They are difficult to teach because while being conceptually very simple, they come with a lot of new terminology, and often no clear use-case. This makes them appear far more monstrous than they are. Luckily for us, we have a couple ideal use-cases, both of which are extremely typical in C, and will likely end up being how you use pointers 90% of the time.</p>

<p>The reason we need pointers in C is because of how function calling works. When you call a function in C the arguments are always passed <em>by value</em>. This means <em>a copy</em> of them is passed to the function you call. This is true for <code>int</code>, <code>long</code>, <code>char</code>, and user defined <code>struct</code> types such as <code>lval</code>. Most of the time this is great but occasionally it can cause issues.</p>

<p>A common problem is if we have a large struct containing many other sub structs we wish to pass around. Every time we call a function we must create another copy of it. Suddenly the amount of data that needs to be copied around just to call a function can become huge!</p>

<p>A second problem is this. When we define a <code>struct</code>, it is always a fixed size. It has a limited number of fields, and each of these fields must be a type which itself is limited in size. If I want to call a function with just <em>a list of things</em>, where the number of <em>things</em> varies from call to call, clearly I can't use a <code>struct</code> to do this.</p>

<p>To get around these issues the developers of C (or y'know...someone) came up with a clever idea. They imagined computer memory as a single huge list of bytes. In this list each byte can be given a global index, or position in this list. The first byte is numbered 0, the second is 1, etc.</p>

<p>In this case, all the data in the computer, including the structs and variables used in the currently running program, start at some index in this huge list. If, rather than copying the data itself to a function, we instead copy a number representing the <em>index</em> at where this data starts, any amount of data can be accessed, just by copying a single number.</p>

<p>By using <em>addresses</em> instead of the actual data, we can allow a function to access and modify some location in memory without having to make a copy of it. Functions can also use pointers to do other cool stuff, like output data to some address given as input.</p>

<p>Because the total size of computer memory is fixed, the number of bytes needed to represent an address always the same. But if we keep track of it, the number of bytes the address points to can grown and shrink. This means we can create a variable sized data-structure and still sort of <em>pass</em> it to a function, which can inspect and modify it.</p>

<p>So a pointer is just a number. A number representing the starting index of some data in memory. The type of the pointer hints to us, and the compiler, how much data might be accessible at this location.</p>

<p>We can declare pointer types by suffixing existing ones with the the <code>*</code> character. We've seen some examples of this already with <code>mpc_parser_t*</code> or <code>mpc_ast_t*</code>.</p>

<p>To create a pointer to some data we have already, we need to get an index, or <em>address</em>. To get the address of a some data we use the <code>&amp;</code> operator. Again you&#39;ve seen this before when we passed in a pointer to <code>mpc_parse</code> so it would output into our <code>mpc_result_t</code>.</p>

<p>Finally to get the data at an address, called <em>dereferencing</em>, we use the <code>*</code> operator on the left hand size of a variable. To get the data at the field of a pointer to a struct we use the arrow <code>-&gt;</code>, as seen in chapter 7.</p>


<h2>The Stack &amp; The Heap</h2> <hr/>

<p>I said that memory can be visualized of as one long list of bytes. Actually it is better to imagine it split into two sections. These sections are called <em>The Stack</em> and <em>The Heap</em>.</p>

<p>Some of you may have heard tales of these mysterious locations, such as <em>"the stack grows down but the heap grows up"</em>, or <em>"there can be many stacks, but only one heap"</em>. Ignore this gossip spread by Perl and Java programmers. In C there is no such mythology. The stack and the heap are common as mud, and well known.</p>

<h3>The Stack</h3>

<div class='pull-right alert alert-warning' style="margin: 15px; text-align: center;">
  <img src="/static/img/building.png" alt="building"/>
  <p><small>The Stack &bull; Like what you do with bricks.</small></p>
</div>

<p>The Stack is the memory where your program lives. It is where all of your temporary variables and data structures exist as you manipulate and edit them. Each time you call a function a new area of the stack is put aside for it to use. Into this area are put copies of any arguments passed to the function, as well as some bookkeeping data such as who the caller was, and what to do when finished. When the function is done the area it used is unallocated, ready for use again by someone else.</p>

<p>I like to think of the stack as a building site. Each time we need to do something new we corner off a section of space, enough for our tools and materials, and set to work. We can still go to other parts of the site, or go off-site, if we need certain things, but all our work is done in this section. Once we are done with some task, we take what we&#39;ve constructed to a new place and clean up that section of the space we've been using to make it.</p>

<h3>The Heap</h3>

<div class='pull-right alert alert-warning' style="margin: 15px; text-align: center;">
  <img src="/static/img/storage.png" alt="storage"/>
  <p><small>The Heap &bull; U LOCK. KEEP KEY.</small></p>
</div>

<p>The Heap is a section of memory put aside for storage of objects with a longer lifespan. Memory in this area has to be manually allocated and deallocated. To allocate new memory the <code>malloc</code> function is used. This function takes as input the number of bytes required, and returns back a pointer to a new block of memory with that many bytes set aside.</p>

<p>When done with the memory at that location it must be released again. To do this the pointer recieved from <code>malloc</code> should be passed to the <code>free</code> function.</p>

<p>Using the Heap is trickier than the Stack because it requires the programmer to remember to call <code>free</code> and to call it correctly. If he or she doesn't, the program may continuously allocate more and more memory. This is called a <em>memory leak</em>. A easy rule to avoid this is to ensure for each <code>malloc</code> there is a corrisponding (and only one corrisponding) <code>free</code>. If this can always be ensured the program should be handling The Heap correctly.</p>

<p>I Imagine the Heap like a huge U-Store-It. We can call up the reception with <code>malloc</code> and request a number of boxes. With these boxes we can do what we want, and we know they will persist no matter how messy the building site gets. We can take things to and from the U-Store-It and the building site. It is useful to store materials and large objects which we only need to retrieve once in a while. The only problem is we need to remember to call the receptionist again with <code>free</code> when we are done. Otherwise soon we&#39;ll have requested all the boxes, have no space, and run up a huge bill.</p>


<h2>Adding Features</h2> <hr/>

<p>You'll notice in the following chapters that adding new features to our language usually consists of a number of steps.</p>

<table class='table'>
  <tr><td><strong>Step 0</strong></td><td>Add any new syntax for this data type to the <code>mpc</code> language grammar.</td></tr>
  <tr><td><strong>Step 1</strong></td><td>Add a new type of possible data to the <code>lval</code> struct.</td></tr>
  <tr><td><strong>Step 2</strong></td><td>Add new functions for reading in this data type from the <em>abstract syntax tree</em>.</td></tr>
  <tr><td><strong>Step 3</strong></td><td>Add new functions for evaluating and manipulating this data type.</td></tr>
</table>

<p>This is exactly what we're going to do now for our S-Expression data type.</p>


<h2>Parsing Expressions</h2> <hr/>

<p>The syntax for S-Expressions is really easy. It simply conists of a number of other Expressions between parenthesis, where an Expression can be a number, operator, or other S-Expression . We can modify our existing parse rules to reflect this. We also change our <code>operator</code> rule to now be called <code>symbol</code>. This is in anticipation of adding more operators and functions later.</p>

<pre><code data-language='c'>mpc_parser_t* Number = mpc_new(&quot;number&quot;);
mpc_parser_t* Symbol = mpc_new(&quot;symbol&quot;);
mpc_parser_t* Sexpr  = mpc_new(&quot;sexpr&quot;);
mpc_parser_t* Expr   = mpc_new(&quot;expr&quot;);
mpc_parser_t* Lispy  = mpc_new(&quot;lispy&quot;);

mpca_lang(
  &quot;                                          \
    number : /-?[0-9]+/ ;                    \
    symbol : &#39;+&#39; | &#39;-&#39; | &#39;*&#39; | &#39;/&#39; ;         \
    sexpr  : &#39;(&#39; &lt;expr&gt;* &#39;)&#39; ;               \
    expr   : &lt;number&gt; | &lt;symbol&gt; | &lt;sexpr&gt; ; \
    lispy  : /^/ &lt;expr&gt;* /$/ ;               \
  &quot;,
  Number, Symbol, Sexpr, Expr, Lispy);</code></pre>

<p>We should also remember to cleanup these rules on exit.</p>

<pre><code data-language='c'>mpc_cleanup(5, Number, Symbol, Sexpr, Expr, Lispy);</code></pre>


<h2>Expression Structure</h2> <hr/>

<p>We need a way to store these S-Expressions internally as <code>lval</code>. Therefore we're going to add two new types to the <code>type</code> enum. The first new type is <em>symbol</em>, which we're going to use to represent operators such as <code>+</code>, and later on variables and functions. The second new type is for <em>S-Expressions</em>.</p>

<pre><code data-language='c'>/* Add SYM and SEXPR as possible lval types. */
enum { LVAL_ERR, LVAL_NUM, LVAL_SYM, LVAL_SEXPR };
</code></pre>

<p>We're also going to change how some of these are represented in the data structure. To represent symbols we're going to use a string. S-Expressions are variable length <em>lists</em> of other expressions, which we are themselves <code>lval</code>. As we learnt at the beginning of this chapter we can't create variable length structures, which means we are going to need to use a pointer. At the location pointed to by this pointer we are going to store a list of <code>lval*</code> (pointers to the other <code>lval</code>). Therefore our field should be a double pointer type <code>lval**</code>. This is read as a <em>pointer to pointers</em>.</p>

<p>We will also need to keep track of how many <code>lval*</code> are in this list, so we add an extra field in the <code>lval</code> struct called <code>count</code> to record this.</p> 

<p>Finally we will change the representation of an <em>error</em> from an <code>int</code> to a string. This means we can store a unique error message rather than just an error code. This will make our error reporting better and more flexible, and we can get rid of the original error <code>enum</code>. Our updated <code>lval</code> struct looks like this.</p>

<pre><code data-language='c'>typedef struct lval {
  int type;

  long num;

  /* Error and Symbol types have some string data */
  char* err;
  char* sym;

  /* Record Number of other &quot;lvals&quot; and a pointer to a list of &quot;lval&quot; pointers */
  int count;
  struct lval** cell;

} lval;</code></pre>


<h2>Constructors &amp; Destructors</h2> <hr/>

<p>Now when we build an <code>lval</code> it may contain pointers to other things that have been allocated on the heap. This means we need to be careful. Whenever we are done with this <code>lval</code> we will also need to delete the things it points to on he heap. We will have to make a rule to ourselves. Whenever we free the memory allocated for an <code>lval</code>, we also free all the things it points to.</p>

<p>We can change our <code>lval</code> construction functions to return pointers to an <code>lval</code>, rather than one directly. This will make keeping track of <code>lval</code> easier. For this we need to use <code>malloc</code> to allocate enough space for the <code>lval</code> struct, and then to fill in the fields with the relevant information using this arrow operator <code>-&gt;</code>.</p>

<pre><code data-language='c'>/* Construct a pointer to a new Number lval */ 
lval* lval_num(long x) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_NUM;
  v-&gt;num = x;
  return v;
}

/* Construct a pointer to a new Error lval */ 
lval* lval_err(char* m) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_ERR;
  v-&gt;err = malloc(strlen(m) + 1);
  strcpy(v-&gt;err, m);
  return v;
}

/* Construct a pointer to a new Symbol lval */ 
lval* lval_sym(char* s) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_SYM;
  v-&gt;sym = malloc(strlen(s) + 1);
  strcpy(v-&gt;sym, s);
  return v;
}

/* A pointer to a new empty Sexpr lval */
lval* lval_sexpr(void) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_SEXPR;
  v-&gt;count = 0;
  v-&gt;cell = NULL;
  return v;
}
</code></pre>


<div class="alert alert-warning">
  <p><strong>Why are you using <code>strlen(s) + 1</code>?</strong></p>

  <p>In C strings are <em>null terminated</em>. This means that the final character of them is always the zero character <code>\0</code>. This is a convention in C to signal the end of a string. It is important that all strings are stored this way otherwise programs will break in nasty ways.</p>
  
  <p>The <code>strlen</code> function only returns the number of bytes in a string <em>excluding</em> the null terminator. This is why we need to add one, to ensure there is enough allocated space for it all!</p>
</div>

<p>We now need a special function to delete <code>lval*</code>. This should call <code>free</code> on the pointer itself to release the memory aquired from <code>malloc</code>, but more importantly it should inspect the type of the <code>lval</code>, and release any memory pointed to by its fields. If we match every call to one of the above construction functions with <code>lval_del</code> we can ensure we will get no memory leaks.</p>

<pre><code class="lang-c">void lval_del(lval* v) {

  switch (v-&gt;type) {
    /* Do nothing special for number type */
    case LVAL_NUM: break;

    /* For Err or Sym free the string data */
    case LVAL_ERR: free(v-&gt;err); break;
    case LVAL_SYM: free(v-&gt;sym); break;

    /* If Sexpr then delete all elements inside */
    case LVAL_SEXPR:
      for (int i = 0; i &lt; v-&gt;count; i++) {
        lval_del(v-&gt;cell[i]);
      }
      /* Also free the memory allocated to contain the pointers */
      free(v-&gt;cell);
    break;
  }

  /* Finally free the memory allocated for the &quot;lval&quot; struct itself */
  free(v);
}</code></pre>
    
    
<h2>Reading Expressions</h2> <hr/>

<p>We are going to use S-Expressions to represent our inputs before we evaluate them. First we are going to <em>read</em> in the program and construct an <code>lval*</code> that represents it all. Then we are going to <em>evaluate</em> this Expression to get the result of our program. This first stage should convert the <em>abstract syntax tree</em> into an S-Expression, and the second stage should evaluate this S-Expression using our normal lisp rules.</p>

<p>To complete the first stage we can recursively parse each node of the tree, and construct different <code>lval</code> types depending on the <code>tag</code> and <code>contents</code> fields of the node.</p>

<p>If the given node is a <code>number</code> or <code>symbol</code>, then it returns an <code>lval*</code> for those types. If it is the <code>root</code> or an <code>sexpr</code>, then it creates an empty S-Expression and slowly adds each valid sub-expression contained in the tree.</p>

<p>We look at each child of the tree and append it to the <code>lval*</code> using a new function <code>lval_add</code>.

<p>The <code>lval_add</code> function increases the count of the Expression list by one, and then uses <code>realloc</code> to reallocate the amount of space required by <code>v-&gt;cell</code>. This new space can be used to store the extra <code>lval*</code> required so it sets the final value of the list with <code>v-&gt;cell[v-&gt;count-1]</code> to the value <code>lval* x</code> passed in. It returns the newly modified <code>lval*</code>.</p>

<pre><code class="lang-c">lval* lval_add(lval* v, lval* x) {
  v-&gt;count++;
  v-&gt;cell = realloc(v-&gt;cell, sizeof(lval*) * v-&gt;count);
  v-&gt;cell[v-&gt;count-1] = x;
  return v;
}

lval* lval_read_num(mpc_ast_t* t) {
  long x = strtol(t-&gt;contents, NULL, 10);
  return errno != ERANGE ? lval_num(x) : lval_err(&quot;invalid number&quot;);
}

lval* lval_read(mpc_ast_t* t) {

  /* If Symbol or Number return conversion to that type */
  if (strstr(t-&gt;tag, &quot;number&quot;)) { return lval_read_num(t); }
  if (strstr(t-&gt;tag, &quot;symbol&quot;)) { return lval_sym(t-&gt;contents); }

  /* If root (&gt;) or sexpr then create empty list */
  lval* x = NULL;
  if (strcmp(t-&gt;tag, &quot;&gt;&quot;) == 0) { x = lval_sexpr(); } 
  if (strstr(t-&gt;tag, &quot;sexpr&quot;))  { x = lval_sexpr(); }

  /* Fill this list with any valid expression contained within */
  for (int i = 0; i &lt; t-&gt;children_num; i++) {
    if (strcmp(t-&gt;children[i]-&gt;contents, &quot;(&quot;) == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;contents, &quot;)&quot;) == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;contents, &quot;}&quot;) == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;contents, &quot;{&quot;) == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;tag,  &quot;regex&quot;) == 0) { continue; }
    x = lval_add(x, lval_read(t-&gt;children[i]));
  }

  return x;
}</code></pre>


<h2>Printing Expressions</h2> <hr/>

<p>We are so close to trying out all of our new changes! The final step is to modify our print function to take <code>lval*</code> and to be able to print out S-Expressions. With this we can see how the <em>reading</em> phase works by printing out the resulting S-Expression. To print out S-Expressions we can create another function that loops over all the sub-expressions of an expression and prints these individually separated by spaces.</p>

<pre><code class="lang-c">void lval_expr_print(lval* v, char open, char close) {
  putchar(open);
  for (int i = 0; i &lt; v-&gt;count; i++) {

    /* Print Value contained within */
    lval_print(v-&gt;cell[i]);

    /* Don&#39;t print trailing space if last element */
    if (i != (v-&gt;count-1)) {
      putchar(&#39; &#39;);
    }
  }
  putchar(close);
}

void lval_print(lval* v) {
  switch (v-&gt;type) {
    case LVAL_NUM:   printf(&quot;%li&quot;, v-&gt;num); break;
    case LVAL_ERR:   printf(&quot;Error: %s&quot;, v-&gt;err); break;
    case LVAL_SYM:   printf(&quot;%s&quot;, v-&gt;sym); break;
    case LVAL_SEXPR: lval_expr_print(v, &#39;(&#39;, &#39;)&#39;); break;
  }
}

void lval_println(lval* v) { lval_print(v); putchar(&#39;\n&#39;); }</code></pre>

<div class="alert alert-warning">
  <p><strong>I can't declare those functions because they depend on each other.</strong></p>

  <p>The <code>lval_expr_print</code> function relies on the <code>lval_print</code> function being delcared before it and vice-versa. There is no way we can order them in the source file to resolve this. Instead we need to <em>forward declare</em> one of them. This is declaring a function without giving it a body. It lets other functions call it, while allowing you to define it again later on. To do this simply write the function definition but intead of the body put a semicolon <code>;</code>. In this example we should put <code>void lval_print(lval* v);</code> somewhere in the source file before <code>lval_expr_print</code>.</p>
  
  <p>You'll definitely run into this later, so try to remember it!</p>
</div>


<p>In our main loop, we can remove the evaluation for now, and instead try reading in the result and printing out what we have read.</p>

<pre><code data-language='c'>lval* x = lval_read(r.output);
lval_println(x);
lval_del(x);</code></pre>

<p>If this is successful you should see something like the following when entering input to your program.</p>

<pre><code data-language='lispy'>lispy&gt; + 2 2
(+ 2 2)
lispy&gt; + 2 (* 7 6) (* 2 5)
(+ 2 (* 7 6) (* 2 5))
lispy&gt; *     55     101  (+ 0 0 0)
(* 55 101 (+ 0 0 0))
lispy&gt;</code></pre>


<h2>Evaluating Expressions</h2> <hr/>

<p>The behaviour of our evaluation function is the same as before. We need to adapt it to dealing with <code>lval*</code> and our more relaxed definition of what constitutes an expression. We can think of our evaluation function as a kind of transformer. It takes in some <code>lval*</code> and transforms it in some way to some new <code>lval*</code>. In some cases it can just return exactly the same thing. In other cases it may modify the input <code>lval*</code> and the return it. In many cases it will delete the input, and return something completely different. If this is the case we must always remember to delete the input <code>lval*</code> if we are going to return something new.</p>

<p>For S-Expressions we first evaluate all the children of the S-Expression. If any of these children are errors we return the first error we encounter using a function we'll define later called <code>lval_take</code>.</p>

<p>We then check for the empty expression. If the S-Expression has no children we just return it directly. This corrisponds to the construct <code>()</code>. We also check for a single expression. This is an expression with only one child such as <code>(5)</code>. In this case we return the single expression contained within the parenthesis. If neither of these are the case we know we have a valid expression with more than one child.</p>

<p>We extract the first element of the expression using a function we'll define later called <code>lval_pop</code>. We then need to check this is a <em>symbol</em> and not a <em>number</em>. If it is a symbol we check what symbol it is and find a result using <code>builtin_op</code>, otherwise we delete the first element and the values passed into the evaluation function, returning an error.</p>

<p>To evaluation all other types we just return them directly back.</p>

<pre><code class="lang-c">lval* lval_eval_sexpr(lval* v) {

  /* Evaluate Children */
  for (int i = 0; i &lt; v-&gt;count; i++) {
    v-&gt;cell[i] = lval_eval(v-&gt;cell[i]);
  }

  /* Error Checking */
  for (int i = 0; i &lt; v-&gt;count; i++) {
    if (v-&gt;cell[i]-&gt;type == LVAL_ERR) { return lval_take(v, i); }
  }

  /* Empty Expression */
  if (v-&gt;count == 0) { return v; }

  /* Single Expression */
  if (v-&gt;count == 1) { return lval_take(v, 0); }

  /* Ensure First Element is Symbol Start */
  lval* f = lval_pop(v, 0);
  if (f-&gt;type != LVAL_SYM) {
    lval_del(f); lval_del(v);
    return lval_err(&quot;S-expression Does not start with symbol!&quot;);
  }

  /* Call builtin with operator */
  lval* result = builtin_op(v, f-&gt;sym);
  lval_del(f);
  return result;
}

lval* lval_eval(lval* v) {
  /* Evaluate Sexpressions */
  if (v-&gt;type == LVAL_SEXPR) { return lval_eval_sexpr(v); }
  /* All other lval types remain the same */
  return v;
}</code></pre>

<p>There are two functions we've used and not defined in the above code. These are <code>lval_pop</code> and <code>lval_take</code>.</p>

<p>The <code>lval_pop</code> function extracts a single element from an Expression at index <code>i</code> and shifts the rest of the list backward so that it no longer contains that <code>lval*</code>. It then returns the extracted value. Notice that it doesn't delete the input list. It is like taking an element from a list and popping it out. This means both the element popped and the old list need to be deleted at some point with <code>lval_del</code>.</p>

<p>The <code>lval_take</code> function is similar to <code>lval_pop</code> but it deletes the list it has extracted the item from. This is like taking an item from the list and deleting the rest. It is a slight variation on <code>lval_pop</code> but it makes our code easier to read in some places.</p>

<pre><code class="lang-c">lval* lval_pop(lval* v, int i) {
  /* Find the item at &quot;i&quot; */
  lval* x = v-&gt;cell[i];

  /* Shift the memory following the item at &quot;i&quot; over the top of it */
  memmove(&amp;v-&gt;cell[i], &amp;v-&gt;cell[i+1], sizeof(lval*) * (v-&gt;count-i-1));

  /* Decrease the count of items in the list */
  v-&gt;count--;

  /* Reallocate the memory used */
  v-&gt;cell = realloc(v-&gt;cell, sizeof(lval*) * v-&gt;count);
  return x;
}

lval* lval_take(lval* v, int i) {
  lval* x = lval_pop(v, i);
  lval_del(v);
  return x;
}</code></pre>

<p>We also need to define an evaluation function for operators called <code>builtin_op</code>. This is like the <code>eval_op</code> function used in our previous chapter but modified to take a single <code>lval*</code> representing a list of all the arguments to operate on. It needs to do some more rigirous error checking. If any of the inputs are a non-number <code>lval*</code> we need to return an error.</p>

<p>So first it checks that all the sub-expression in the input are numbers. It then pops the first sub-expression to start. If there are no more sub-expressions and the operator is subtraction it performs unary negation on this first number. This makes expressions such as <code>(- 5)</code> evaluate correctly.</p>

<p>If there are more sub-expressions it constantly pops the next one from the list and performs arithmetic depending on which operator we're meant to be using. If a zero is encountered on division it deletes the temporary <code>lval*</code> <code>x</code>, <code>y</code>, and the argument list <code>a</code>, and returns an error.</p>

<p>If there have been no errors the input arguments are deleted and the new expression returned.</p>

<pre><code class="lang-c">lval* builtin_op(lval* a, char* op) {
  
  /* Ensure all arguments are numbers */
  for (int i = 0; i < a->count; i++) {
    if (a&gt;cell[i]-&gt;type != LVAL_NUM) {
      lval_del(a);
      return lval_err(&quot;Cannot operator on non number!&quot;);
    }
  }
  
  /* Pop the first element */
  lval* x = lval_pop(a, 0);

  /* If no arguments and sub then perform unary negation */
  if ((strcmp(op, &quot;-&quot;) == 0) &amp;&amp; a-&gt;count == 0) { x-&gt;num = -x-&gt;num; }

  /* While there are still elements remaining */
  while (a-&gt;count &gt; 0) {

    /* Pop the next element */
    lval* y = lval_pop(a, 0);

    /* Perform operation */
    if (strcmp(op, &quot;+&quot;) == 0) { x-&gt;num += y-&gt;num; }
    if (strcmp(op, &quot;-&quot;) == 0) { x-&gt;num -= y-&gt;num; }
    if (strcmp(op, &quot;*&quot;) == 0) { x-&gt;num *= y-&gt;num; }
    if (strcmp(op, &quot;/&quot;) == 0) {
      if (y-&gt;num == 0) {
        lval_del(x); lval_del(y); lval_del(a);
        x = lval_err(&quot;Division By Zero!&quot;); break;
      } else {
        x-&gt;num /= y-&gt;num;
      }
    }

    /* Delete element now finished with */
    lval_del(y);
  }

  /* Delete input expression and return result */
  lval_del(a);
  return x;
}</code></pre>

<p>This completes our evalation functions. We just need to change <code>main</code> again so it passes the input through this evaluation before printing it.</p>

<pre><code data-language='c'>lval* x = lval_eval(lval_read(r.output));
lval_println(x);
lval_del(x);
</code></pre>

<p>Now you should now be able to evaluate expressions correctly in the same way as in the previous chapter. Take a little breather and have a play around with the new evaluation. Make sure everything is working correctly, and the behaviour is as expected. In the next chapter we're going to make great use of these changes to implement some cool new features.</p>

<pre><code data-language='lispy'>lispy&gt; + 1 (* 7 5) 3
39
lispy&gt; (- 100)
-100
lispy&gt;
()
lispy&gt; /
/
lispy&gt; (/ ())
Error: Cannot operator on non number!
lispy&gt;</code></pre>


<h2>Reference</h2> <hr/>

<div class="panel-group alert alert-warning" id="accordion">
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne">
          s_expressions.c
        </a>
      </h4>
    </div>
    <div id="collapseOne" class="panel-collapse collapse">
      <div class="panel-body">
<pre><code data-language='c'>#include "mpc.h"

#ifdef _WIN32

static char buffer[2048];

char* readline(char* prompt) {
  fputs("lispy&gt; ", stdout);
  fgets(buffer, 2048, stdin);
  char* cpy = malloc(strlen(buffer)+1);
  strcpy(cpy, buffer);
  cpy[strlen(cpy)-1] = '\0';
  return cpy;
}

void add_history(char* unused) {}

#else

#include &lt;editline/readline.h&gt;
#include &lt;editline/history.h&gt;

#endif

/* Add SYM and SEXPR as possible lval types */
enum { LVAL_ERR, LVAL_NUM, LVAL_SYM, LVAL_SEXPR };

typedef struct lval {
  int type;

  long num;
  
  /* Error and Symbol types have some string data */
  char* err;
  char* sym;
  
  /* Record Number of other "lvals" and a pointer to a list of "lval" pointers */
  int count;
  struct lval** cell;
  
} lval;

/* Construct a pointer to a new Number lval */ 
lval* lval_num(long x) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_NUM;
  v-&gt;num = x;
  return v;
}

/* Construct a pointer to a new Error lval */ 
lval* lval_err(char* m) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_ERR;
  v-&gt;err = malloc(strlen(m) + 1);
  strcpy(v-&gt;err, m);
  return v;
}

/* Construct a pointer to a new Symbol lval */ 
lval* lval_sym(char* s) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_SYM;
  v-&gt;sym = malloc(strlen(s) + 1);
  strcpy(v-&gt;sym, s);
  return v;
}

/* A pointer to a new empty Sexpr lval */
lval* lval_sexpr(void) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_SEXPR;
  v-&gt;count = 0;
  v-&gt;cell = NULL;
  return v;
}

void lval_del(lval* v) {

  switch (v-&gt;type) {
    /* Do nothing special for number type */
    case LVAL_NUM: break;
    
    /* For Err or Sym free the string data */
    case LVAL_ERR: free(v-&gt;err); break;
    case LVAL_SYM: free(v-&gt;sym); break;
    
    /* If Sexpr then delete all elements inside */
    case LVAL_SEXPR:
      for (int i = 0; i &lt; v-&gt;count; i++) {
        lval_del(v-&gt;cell[i]);
      }
      /* Also free the memory allocated to contain the pointers */
      free(v-&gt;cell);
    break;
  }
  
  /* Finally free the memory allocated for the "lval" struct itself */
  free(v);
}

lval* lval_add(lval* v, lval* x) {
  v-&gt;count++;
  v-&gt;cell = realloc(v-&gt;cell, sizeof(lval*) * v-&gt;count);
  v-&gt;cell[v-&gt;count-1] = x;
  return v;
}

lval* lval_pop(lval* v, int i) {
  /* Find the item at "i" */
  lval* x = v-&gt;cell[i];
  
  /* Shift the memory following the item at "i" over the top of it */
  memmove(&amp;v-&gt;cell[i], &amp;v-&gt;cell[i+1], sizeof(lval*) * (v-&gt;count-i-1));
  
  /* Decrease the count of items in the list */
  v-&gt;count--;
  
  /* Reallocate the memory used */
  v-&gt;cell = realloc(v-&gt;cell, sizeof(lval*) * v-&gt;count);
  return x;
}

lval* lval_take(lval* v, int i) {
  lval* x = lval_pop(v, i);
  lval_del(v);
  return x;
}

void lval_print(lval* v);

void lval_expr_print(lval* v, char open, char close) {
  putchar(open);
  for (int i = 0; i &lt; v-&gt;count; i++) {
    
    /* Print Value contained within */
    lval_print(v-&gt;cell[i]);
    
    /* Don't print trailing space if last element */
    if (i != (v-&gt;count-1)) {
      putchar(' ');
    }
  }
  putchar(close);
}

void lval_print(lval* v) {
  switch (v-&gt;type) {
    case LVAL_NUM:   printf("%li", v-&gt;num); break;
    case LVAL_ERR:   printf("Error: %s", v-&gt;err); break;
    case LVAL_SYM:   printf("%s", v-&gt;sym); break;
    case LVAL_SEXPR: lval_expr_print(v, '(', ')'); break;
  }
}

void lval_println(lval* v) { lval_print(v); putchar('\n'); }

lval* builtin_op(lval* a, char* op) {
  
  /* Ensure all arguments are numbers */
  for (int i = 0; i &lt; a-&gt;count; i++) {
    if (a-&gt;cell[i]-&gt;type != LVAL_NUM) {
      lval_del(a);
      return lval_err("Cannot operator on non number!");
    }
  }
  
  /* Pop the first element */
  lval* x = lval_pop(a, 0);
  
  /* If no arguments and sub then perform unary negation */
  if ((strcmp(op, "-") == 0) &amp;&amp; a-&gt;count == 0) { x-&gt;num = -x-&gt;num; }
  
  /* While there are still elements remaining */
  while (a-&gt;count &gt; 0) {
  
    /* Pop the next element */
    lval* y = lval_pop(a, 0);
    
    /* Perform operation */
    if (strcmp(op, "+") == 0) { x-&gt;num += y-&gt;num; }
    if (strcmp(op, "-") == 0) { x-&gt;num -= y-&gt;num; }
    if (strcmp(op, "*") == 0) { x-&gt;num *= y-&gt;num; }
    if (strcmp(op, "/") == 0) {
      if (y-&gt;num == 0) {
        lval_del(x); lval_del(y); lval_del(a);
        x = lval_err("Division By Zero.");
        break;
      } else {
        x-&gt;num /= y-&gt;num;
      }
    }
    
    /* Delete element now finished with */
    lval_del(y);
  }
  
  /* Delete input expression and return result */
  lval_del(a);
  return x;
}

lval* lval_eval(lval* v);

lval* lval_eval_sexpr(lval* v) {
  
  /* Evaluate Children */
  for (int i = 0; i &lt; v-&gt;count; i++) {
    v-&gt;cell[i] = lval_eval(v-&gt;cell[i]);
  }
  
  /* Error Checking */
  for (int i = 0; i &lt; v-&gt;count; i++) {
    if (v-&gt;cell[i]-&gt;type == LVAL_ERR) { return lval_take(v, i); }
  }
  
  /* Empty Expression */
  if (v-&gt;count == 0) { return v; }
  
  /* Single Expression */
  if (v-&gt;count == 1) { return lval_take(v, 0); }
  
  /* Ensure First Element is Symbol Start */
  lval* f = lval_pop(v, 0);
  if (f-&gt;type != LVAL_SYM) {
    lval_del(f); lval_del(v);
    return lval_err("S-expression Does not start with symbol.");
  }
  
  /* Call builtin with operator */
  lval* result = builtin_op(v, f-&gt;sym);
  lval_del(f);
  return result;
}

lval* lval_eval(lval* v) {
  /* Evaluate Sexpressions */
  if (v-&gt;type == LVAL_SEXPR) { return lval_eval_sexpr(v); }
  /* All other lval types remain the same */
  return v;
}

lval* lval_read_num(mpc_ast_t* t) {
  long x = strtol(t-&gt;contents, NULL, 10);
  return errno != ERANGE ? lval_num(x) : lval_err("invalid number");
}

lval* lval_read(mpc_ast_t* t) {
  
  /* If Symbol or Number return conversion to that type */
  if (strstr(t-&gt;tag, "number")) { return lval_read_num(t); }
  if (strstr(t-&gt;tag, "symbol")) { return lval_sym(t-&gt;contents); }
  
  /* If root (&gt;) or sexpr then create empty list */
  lval* x = NULL;
  if (strcmp(t-&gt;tag, "&gt;") == 0) { x = lval_sexpr(); } 
  if (strstr(t-&gt;tag, "sexpr"))  { x = lval_sexpr(); }
  
  /* Fill this list with any valid expression contained within */
  for (int i = 0; i &lt; t-&gt;children_num; i++) {
    if (strcmp(t-&gt;children[i]-&gt;contents, "(") == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;contents, ")") == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;contents, "}") == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;contents, "{") == 0) { continue; }
    if (strcmp(t-&gt;children[i]-&gt;tag,  "regex") == 0) { continue; }
    x = lval_add(x, lval_read(t-&gt;children[i]));
  }
  
  return x;
}

int main(int argc, char** argv) {
  
  mpc_parser_t* Number = mpc_new("number");
  mpc_parser_t* Symbol = mpc_new("symbol");
  mpc_parser_t* Sexpr  = mpc_new("sexpr");
  mpc_parser_t* Expr   = mpc_new("expr");
  mpc_parser_t* Lispy  = mpc_new("lispy");
  
  mpca_lang(
    "                                          \
      number : /-?[0-9]+/ ;                    \
      symbol : '+' | '-' | '*' | '/' ;         \
      sexpr  : '(' &lt;expr&gt;* ')' ;               \
      expr   : &lt;number&gt; | &lt;symbol&gt; | &lt;sexpr&gt; ; \
      lispy  : /^/ &lt;expr&gt;* /$/ ;               \
    ",
    Number, Symbol, Sexpr, Expr, Lispy);
  
  puts("Lispy Version 0.0.0.0.5");
  puts("Press Ctrl+c to Exit\n");
  
  while (1) {
  
    char* input = readline("lispy&gt; ");
    add_history(input);
    
    mpc_result_t r;
    if (mpc_parse("&lt;stdin&gt;", input, Lispy, &amp;r)) {
      
      lval* x = lval_eval(lval_read(r.output));
      lval_println(x);
      lval_del(x);
      
      mpc_ast_delete(r.output);
    } else {    
      mpc_err_print(r.error);
      mpc_err_delete(r.error);
    }
    
    free(input);
    
  }
  
  mpc_cleanup(5, Number, Symbol, Sexpr, Expr, Lispy);
  
  return 0;
}
</code></pre>
      </div>
    </div>
  </div>
</div>

<h2>Bonus Marks</h2> <hr/>

<div class="alert alert-warning">
  <ul class="list-group">
    <li class="list-group-item">&bull; TODO</li>
    <li class="list-group-item">&bull; TODO</li>
  </ul>
</div>


<h2>Navigation</h2>

<table class="table" style='table-layout: fixed;'>
  <tr>
    <td class="text-left"><a href="chapter8_error_handling"><h4>&lsaquo; Error Handling</h4></a></td>
    <td class="text-center"><a href="contents"><h4>&bull; Contents &bull;</h4></a></td>
    <td class="text-right"><a href="chapter10_q_expressions"><h4>Q-Expressions &rsaquo;</h4></a></td>
  </tr>
</table>
