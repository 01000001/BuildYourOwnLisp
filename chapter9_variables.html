<h2>Variables</h2>
<p>Our previous example clocked in at about 375 lines of code, but we&#39;re actually at about the half way point of this tutorial. Already we can do a number of cool things that other languages cannot do, such as passing around functions, or blocks of code that can be evaluated.</p>
<p>But out language is still missing some key features that make it practical enough for day to day use. This is what the following chapters will consist of.</p>
<p>We start with variables. A misleading name because our variables wont vary. Our variables are <em>immutable</em> meaning they cannot change. In fact everything in our language has been <em>immutable</em> so far. When we want to edit something we always delete the old thing and return a new thing. It just so happens that in some cases we reuse the data from the old thing internally.</p>
<p>So actually our variables are simply a way of <em>naming things</em>. They let us assign a name to a value, and then let us get a copy of that value later on when we need it. If you think about it this is similar to the behaviour of C, where by all data is passed by value. One difference is that our language wont have any concept of pointers, and so even large amounts of data such as in lists, are essentially passed by value.</p>
<p>To allow for <em>naming things</em> we need to create a structure which stores the name and value of everything named in our program. We call this the <em>environment</em>. When we start a new interactive prompt we want to create a new environment to go along with it, in which each new bit of input is evaluated.</p>
<h3>Function Pointers</h3>
<p>Before we define our environment struct we&#39;re going to update our <code>lval</code> struct. Once we introduce variables, symbols will no longer represent functions in our language, but rather they will represent a lookup into our environment to get some new value back. Therefore we need a new value to represent functions in our language, which we can return once a builtin symbol is found.</p>
<p>To create this new type of <code>lval</code> we are going to use something called a <em>function pointer</em>.</p>
<p>Function pointers are a neat feature of C that lets you store and pass around pointers to functions. These pointers can then be called like normal functions, passing in arguments and getting some result back. </p>
<p>In our previous example all of our builtin functions took an <code>lval*</code> of arguments and returned a <code>lval*</code> result. In our new system we are also going to pass in a pointer to the environment. We can declare a new function pointer type for this definition that looks like this.</p>
<pre><code class="lang-c">typedef lval*(*lbuiltin)(lenv*, lval*);</code></pre>
<p>This looks pretty confusing, but it reads like this. The type <code>lbuiltin</code> is a function pointer returning an <code>lval*</code> and taking in an <code>lenv*</code> and a <code>lval*</code>.</p>
<p>The syntax for function pointers is confusing but it is actually fairly simple. To declare a function pointer one writes the function as if it were a new declaration with the name of the function being the new type or variable name:</p>
<pre><code class="lang-c">lval* lbuiltin(lenv*, lval*);</code></pre>
<p>One then wraps the name in parenthsis and puts a <code>*</code> on the left hand side.</p>
<pre><code class="lang-c">lval* (*lbuiltin)(lenv*, lval*);</code></pre>
<p>In a normal context this would create a variable <code>lbuiltin</code> which is a function pointer. If we prefix it with <code>typedef</code> it converts it into a type declaration with the variable name being the new type name.</p>
<pre><code class="lang-c">typedef lval*(*lbuiltin)(lenv*, lval*);</code></pre>
<h3>Forward Declarations</h3>
<p>We are left with a problem if we want to include this in our <code>lval</code> struct. We can&#39;t declare this function pointer type without first declaring our <code>lval</code> struct - which in turn requires <code>lbuiltin</code> to be defined.</p>
<p>To fix this in C we use what is called a <em>forward declaration</em>. That means we define all the types first, giving them empty bodies, and then fill their bodies later. It looks like this:</p>
<pre><code class="lang-c">/* Forward Declarations */

struct lval;
struct lenv;
typedef struct lval lval;
typedef struct lenv lenv;

/* Lisp Value */

enum { LVAL_ERR, LVAL_NUM, LVAL_SYM, LVAL_FUN, LVAL_SEXPR, LVAL_QEXPR };

typedef lval*(*lbuiltin)(lenv*, lval*);

struct lval {
  int type;

  long num;
  char* err;
  char* sym;
  lbuiltin fun;

  int count;
  lval** cell;
};</code></pre>
<p>In this code we first declare that two structs are coming up, each called <code>lval</code> and <code>lenv</code>. We then use typedef say that <code>struct lval</code> or <code>struct lenv</code> can be written simply as<code>lval</code> or <code>lenv</code>.</p>
<p>Then we declare a function pointer type <code>builtin</code> with the signature described above. Finally we declare the actual body of the <code>struct lval</code> type, which itself includes <code>lval*</code> and <code>builtin</code> fields.</p>
<h3>The Environment</h3>
<p>There are many ways to structure this sort of thing but we are going to go for the simplest, which is just a list of <code>lval*</code>s and a list of corresponding <code>char*</code>s. We also need to remember the number of variables stored.</p>
<pre><code class="lang-c">struct lenv {
  int count;
  char** syms;
  lval** vals;
};</code></pre>
<p>The creation and deletion functions for this environment are pretty simple. Creation just initialises the struct fields. Deletion iterates over the items in both lists and deletes or frees them.</p>
<pre><code class="lang-c">lenv* lenv_new(void) {
  lenv* e = malloc(sizeof(lenv));
  e-&gt;count = 0;
  e-&gt;syms = NULL;
  e-&gt;vals = NULL;
  return e;
}

void lenv_del(lenv* e) {
  for (int i = 0; i &lt; e-&gt;count; i++) {
    free(e-&gt;syms[i]);
    lval_del(e-&gt;vals[i]);
  }
  free(e-&gt;syms);
  free(e-&gt;vals);
  free(e);
}</code></pre>
<p>Finally we need two more functions for getting values from the environment and for putting new variables into it.</p>
<pre><code class="lang-c">lval* lenv_get(lenv* e, lval* k) {

  /* Iterate over all items in environment */
  for (int i = 0; i &lt; e-&gt;count; i++) {
    /* Check if the stored string matches the symbol string */
    /* If it does, return a copy of the value */
    if (strcmp(e-&gt;syms[i], k-&gt;sym) == 0) { return lval_copy(e-&gt;vals[i]); }
  }
  /* If no symbol found return error */
  return lval_err(&quot;unbound symbol!&quot;,);
}</code></pre>
<p>The first function for retriving values is fairly simple. It just loops over all the items in the environment and checks if the symbol matches the stored string. If there is a match it returns a copy of the stored value. If no match is found it returns an error.</p>
<pre><code class="lang-c">void lenv_put(lenv* e, lval* k, lval* v) {

  /* Iterate over all items in environment */
  /* This is to see if variable already exists */
  for (int i = 0; i &lt; e-&gt;count; i++) {

    /* If variable is found delete item at that position */
    /* And replace with variable supplied by user */
    if (strcmp(e-&gt;syms[i], k-&gt;sym) == 0) {
      lval_del(e-&gt;vals[i]);
      e-&gt;vals[i] = lval_copy(v);
      e-&gt;syms[i] = realloc(e-&gt;syms[i], strlen(k-&gt;sym)+1);
      strcpy(e-&gt;syms[i], k-&gt;sym);
      return;
    }
  }

  /* If no existing entry found then allocate space for new entry */
  e-&gt;count++;
  e-&gt;vals = realloc(e-&gt;vals, sizeof(lval*) * e-&gt;count);
  e-&gt;syms = realloc(e-&gt;syms, sizeof(char*) * e-&gt;count);

  /* Copy contents of lval and symbol string into new location */
  e-&gt;vals[e-&gt;count-1] = lval_copy(v);
  e-&gt;syms[e-&gt;count-1] = malloc(strlen(k-&gt;sym)+1);
  strcpy(e-&gt;syms[e-&gt;count-1], k-&gt;sym);
}</code></pre>
<p>The function for putting new variables into the environment is a little bit more complex. First we want to check if a variable with the same name already exists, and if so replace it&#39;s value with the new one. To do this we loop over all the existing variables in the environment and check their name. If they have the same name we delete the values stored at that location and make new copies to store there.</p>
<p>If no variable is found we need to allocate some new space for one (and it&#39;s name) using <code>realloc</code> and then to store a copy of the <code>lval</code> at that location, and a copy of the symbol name.</p>
<h3>Updated Evaluation</h3>
<p>Our new evaluation function, as well as our builtins now need to take into account our environment. This needs to be passed around as a parameter. For our core evaluation function we need to make sure that if we encounter a symbol we get the value it represents from the environment.</p>
<pre><code class="lang-c">lval* lval_eval(lenv* e, lval* v) {
  if (v-&gt;type == LVAL_SYM)   { return lenv_get(e, v); }
  if (v-&gt;type == LVAL_SEXPR) { return lval_eval_sexpr(e, v); }
  return v;
}</code></pre>
<p>Our evaluation of S-Expressions is also slightly different. Firstly we want to ensure that the first element in the expression is a function type (after evaluation). If it is a function type we can call our <code>lbuiltin</code> field <code>fun</code> using the same notation as is used for normal function calls. We need to remember to pass in the environment. We know that builtin function deletes the arguments passed in, so we only need to delete the <code>func</code> value afterward.</p>
<pre><code class="lang-c">lval* lval_eval_sexpr(lenv* e, lval* v) {

  for (int i = 0; i &lt; v-&gt;count; i++) { v-&gt;cell[i] = lval_eval(e, v-&gt;cell[i]); }
  for (int i = 0; i &lt; v-&gt;count; i++) { if (v-&gt;cell[i]-&gt;type == LVAL_ERR) { return lval_take(v, i); } }

  if (v-&gt;count == 0) { return v; }  
  if (v-&gt;count == 1) { return lval_eval(e, lval_take(v, 0)); }

  /* Ensure first element is a function after evaluation */
  lval* func = lval_pop(v, 0);
  if (func-&gt;type != LVAL_FUN) { lval_del(v); lval_del(func); return lval_err(&quot;first element is not a function&quot;); }

  /* If so call function to get result */
  lval* result = func-&gt;fun(e, v);
  lval_del(func);
  return result;
}</code></pre>
<h3>Adapting Builtins</h3>
<p>Now that our builtins are called via function type lvals we need to add them to our environment. First we should built an <code>lval</code> constructor that takes in a <code>lbuiltin</code> function pointer and returns a function type <code>lval</code>. This is pretty straight forward.</p>
<pre><code class="lang-c">lval* lval_fun(lbuiltin func) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_FUN;
  v-&gt;fun = func;
  return v;
}</code></pre>
<p>At the moment our builtin functions might not be the correct type. We need to change their type signature such that they take in some environment, and where appropriate change them to pass this environment into other calls that require it. For example this is how we would change the <code>builtin_eval</code> function. Do this type change for all the other builtin functions as well.</p>
<pre><code class="lang-c">lval* builtin_eval(lenv* e, lval* a) {
  LASSERT(a, (a-&gt;count == 1                 ), &quot;Function &#39;eval&#39; passed too many arguments!&quot;);
  LASSERT(a, (a-&gt;cell[0]-&gt;type == LVAL_QEXPR), &quot;Function &#39;eval&#39; passed incorrect type!&quot;);

  lval* x = lval_take(a, 0);
  x-&gt;type = LVAL_SEXPR;
  return lval_eval(e, x);
}</code></pre>
<p>Next we want to create a function that registers all of our builtins into an environment. </p>
<pre><code class="lang-c">void lenv_add_builtin(lenv* e, char* name, lbuiltin func) {
  lval* k = lval_sym(name);
  lval* v = lval_fun(func);
  lenv_put(e, k, v);
  lval_del(k); lval_del(v);
}

void lenv_add_builtins(lenv* e) {  
  /* List Functions */
  lenv_add_builtin(e, &quot;list&quot;, builtin_list);
  lenv_add_builtin(e, &quot;head&quot;, builtin_head); lenv_add_builtin(e, &quot;tail&quot;,  builtin_tail);
  lenv_add_builtin(e, &quot;eval&quot;, builtin_eval); lenv_add_builtin(e, &quot;join&quot;,  builtin_join);

  /* Mathematical Functions */
  lenv_add_builtin(e, &quot;+&quot;,    builtin_add); lenv_add_builtin(e, &quot;-&quot;,     builtin_sub);
  lenv_add_builtin(e, &quot;*&quot;,    builtin_mul); lenv_add_builtin(e, &quot;/&quot;,     builtin_div);
}</code></pre>
<p>This is fairly straight forward. For each builtin we want to create a function <code>lval</code> and symbol <code>lval</code> with the given name. We then register these with the environment using <code>lenv_put</code>. The environment always  takes or returns copies of a values, so we need to remember to delete these two <code>lval</code>s after registration.</p>
<p>If we split this task into two functions we can neatly register all of our builtins with some environment.</p>
<p>We are almost there now. Our final step is to add the creation of our environment when the interactive prompt is started. We should register all of our builtin functions just after it is created and then remember to delete the environment once we are finished.</p>
<pre><code class="lang-c">lenv* e = lenv_new();
lenv_add_builtins(e);

while (1) {

  fputs(&quot;lispy&gt; &quot;, stdout);
  fgets(input, 2047, stdin);

  mpc_result_t r;
  if (mpc_parse(&quot;&lt;stdin&gt;&quot;, input, Lispy, &amp;r)) {

    lval* x = lval_eval(e, lval_read(r.output));
    lval_println(x);
    lval_del(x);

    mpc_ast_delete(r.output);
  } else {
    mpc_err_print(r.error);
    mpc_err_delete(r.error);
  }

}

lenv_del(e);</code></pre>
<p>If all has worked correctly we should be able to see now that functions are no longer symbols and actually a new type of value.</p>
<pre><code>lispy&gt; +
&lt;function&gt;
lispy&gt; eval (head {+ - + - * /})
&lt;function&gt;
lispy&gt; eval (head {5 10 11 15})
5
lispy&gt; (eval (head {+ - + - * /})) 10 20
30
lispy&gt;</code></pre>
<h3>Define Function</h3>
<p>Our final step is to add a method for a user to define new variables. This is a bit awkward because we need to get the user to pass in a symbol as well as a value to assign to it. Symbols can&#39;t appear on their own though - or the evaluation function will attempt to retrieve a value for them from the environment. The only way we can pass around symbols without them being evaluated is to put them between <code>{}</code> in a quoted expression.</p>
<p>So we&#39;re going to use this technique for our define function. Our define function should take in as it&#39;s first argument a list of N symbols, and after that it should take in another N values. It will then assign the N values to the N symbols.</p>
<pre><code class="lang-c">lval* builtin_def(lenv* e, lval* a) {
  LASSERT(a, (a-&gt;cell[0]-&gt;type == LVAL_QEXPR), &quot;Function &#39;def&#39; passed incorrect type!&quot;);

  /* First argument is symbol list */
  lval* syms = a-&gt;cell[0];

  /* Ensure all elements of first list are symbols */
  for (int i = 0; i &lt; syms-&gt;count; i++) {
    LASSERT(a, (syms-&gt;cell[i]-&gt;type == LVAL_SYM), &quot;Function &#39;def&#39; cannot define non-symbol&quot;);
  }

  /* Check correct number of symbols and values */
  LASSERT(a, (syms-&gt;count == a-&gt;count-1), &quot;Function &#39;def&#39; cannot define incorrect number of values to symbols&quot;);

  /* Assign copies of values to symbols */
  for (int i = 0; i &lt; syms-&gt;count; i++) {
    lenv_put(e, syms-&gt;cell[i], a-&gt;cell[i+1]);
  }

  lval_del(a);
  return lval_sexpr();
}</code></pre>
<p>The first step is to ensure the first argument passed in is both a list, and a list of symbols. Secondly we check that there are the same number of symbols as values passed in. Finally if all these conditions are met we add each value to our environment with the given matching symbol. Finally we delete the arguments and return an empty S Expression as the result.</p>
<p>We need to register this new builtin using our builtin registration function <code>lenv_add_builtins</code> and variables should now work!</p>
<pre><code class="lang-c">/* Variable Functions */
lenv_add_builtin(e, &quot;def&quot;,  builtin_def);</code></pre>
<p>Because our define function takes in a list of symbols we can do some cool things storing and manipulating symbols in lists before passing them to be defined. If everything is working correctly you should get behaviour that looks like this:</p>
<pre><code>lispy&gt; def {x} 100
()
lispy&gt; def {y} 200
()
lispy&gt; x
100
lispy&gt; y
200
lispy&gt; + x y
300
lispy&gt; def {a b} 5 6
()
lispy&gt; + a b
11
lispy&gt; def {arglist} {a b x y}
()
lispy&gt; arglist
{a b x y}
lispy&gt; def arglist 1 2 3 4
()
lispy&gt; list a b x y
{1 2 3 4}
lispy&gt;</code></pre>
<p>Have a bit more of a play around and see what other complex methods are possible for the definition and evaluation of variables. Once we get onto definition functions this is going to be a really cool way of writing code that can re-write, define and manipulate other sections of code.</p>
<h3>Better Error Messages - Variable Arguments</h3>
<p>At the moment our error reporting still kind of sucks. We can report when an error occurs but don&#39;t give the user much information about exactly what went wrong. For example if there is an unbound symbol we should be able to report to the user which symbol exactly was unbound. This can help the user track down errors in case of typos and other trivial problems. Our plan is this - we&#39;re going to try and create a function that can report errors similarly to how <code>printf</code> works. Then we can pass in strings, integers and other data to make our error messages richer.</p>
<p>The <code>printf</code> function is a special function in C because it takes a variable number of arguments. This allows the user to pass in any number of other bits of data and it will use the format string to see how these must be used.</p>
<p>We&#39;re going to modify our <code>lval_err</code> function in the same way so that it takes in a format string, and following that a variable number of arguments. To declare that a function takes variables arguments in the type signature you use ellipses instead of a variable type and name. Like so:</p>
<pre><code class="lang-c">lval* lval_err(char* fmt, ...);</code></pre>
<p>Then inside the function one can use a number of intrinsic C functions to examine what the caller has passed in. The first step is to create a <code>va_list</code> struct and initialise it with <code>va_start</code>, passing in the last named argument. For other purposes it is possible to examine each argument passed in using <code>va_arg</code>, but we are going to pass our variable argument list directly to the <code>vsnprintf</code> function, which takes one as it&#39;s last argument. Once we are done with our variable arguments we must use <code>va_end</code> to cleanup any resources used.</p>
<p>Putting it altogether our new error function will look like this.</p>
<pre><code class="lang-c">lval* lval_err(char* fmt, ...) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_ERR;

  /* Create a va list and initialize it */
  va_list va;
  va_start(va, fmt);

  /* Allocate 512 bytes of space */
  v-&gt;err = malloc(512);

  /* printf into the error string with a maximum of 511 characters */
  vsnprintf(v-&gt;err, 511, fmt, va);

  /* Reallocate to number of bytes actually used */
  v-&gt;err = realloc(v-&gt;err, strlen(v-&gt;err)+1);

  /* Cleanup our va list */
  va_end(va);

  return v;
}</code></pre>
<p>TODO: Mention allocation stuff </p>
<p>We can then start adding in some better error messages. For example in <code>lenv_get</code> when a symbol can&#39;t be found we can return it&#39;s name.</p>
<pre><code class="lang-c">return lval_err(&quot;Unbound Symbol &#39;%s&#39;&quot;, k-&gt;sym);</code></pre>
<p>We can also adapt our <code>LASSERT</code> macro such that it can take variable arguments to be passed into <code>lval_err</code>. On the left hand side of the definition we use the ellipses notation again - but on the right hand side we use a special variable <code>__VA_ARGS__</code> to paste in the contents. We prefix this special variable with two hash signs <code>##</code>. This ensure that it is pasted correctly when the macro is passed no extra arguments. In essence what this does is make sure to remove the leading comma <code>,</code> to appear as if no extra arguments were passed in.</p>
<pre><code class="lang-c">#define LASSERT(args, cond, fmt, ...) if (!(cond)) { lval* err = lval_err(fmt, ##__VA_ARGS__); lval_del(args); return err; }</code></pre>
<p>TODO: Mention re-jigging so as not to delete <code>args</code> before it is used!</p>
<p>Now we can update some of our error messages to make them more informative. For example if the incorrect number of arguments were passed we can specify how many were required and how many were given.</p>
<pre><code class="lang-c">LASSERT(a, (a-&gt;count == 1), &quot;Function &#39;head&#39; passed too many arguments. Got %i, Expected %i.&quot;, a-&gt;count, 1);</code></pre>
<p>We can also improve our error reporting for type errors. We should attempt to report what type was expected by a function and what type it actually got. Before we can do this it would be useful to have a function that took as input some type and returned a string representation of that type.</p>
<pre><code class="lang-c">char* ltype_name(int t) {
  switch(t) {
    case LVAL_FUN: return &quot;Function&quot;;
    case LVAL_NUM: return &quot;Number&quot;;
    case LVAL_ERR: return &quot;Error&quot;;
    case LVAL_SYM: return &quot;Symbol&quot;;
    case LVAL_SEXPR: return &quot;S-Expression&quot;;
    case LVAL_QEXPR: return &quot;Q-Expression&quot;;
    default: return &quot;Unknown&quot;;
  }
}</code></pre>
<p>Then we can use this function in our <code>LASSERT</code> functions to report what was retrieved and what was expected in a useful way.</p>
<pre><code class="lang-c">LASSERT(a, (a-&gt;cell[0]-&gt;type == LVAL_QEXPR), &quot;Function &#39;head&#39; passed incorrect type. Got %s, Expected %s.&quot;, ltype_name(a-&gt;cell[0]-&gt;type), type_name(LVAL_QEXPR));</code></pre>
<p>Our <code>builtin_op</code> function currently reports errors that are ambiguous as to what operator has thrown the error. Again, now we can add this into our error reporting.</p>
<pre><code>if (x-&gt;type != LVAL_NUM) { lval* err = lval_err(&quot;Function &#39;%s&#39; passed incorrect type. Got %s, Expected %s.&quot;, op, ltype_name(x-&gt;type), ltype_name(LVAL_NUM)); lval_del(x); lval_del(y); x = err; break; }</code></pre>
<p>TODO: Mention argument reshuffle!</p>
<p>I&#39;ll leave it to you to improve the error reporting across the rest of the system. This should make debugging many of the next stages much easier as we begin to write real, and complicated code using our new language!</p>
<p>TODO: Give example terminal output of error messages in use.</p>
<h3>Tutorial Code</h3>
<p><a href="">example7.c</a></p>
<h3>Bonus Marks</h3>
<ul>
<li></li>
</ul>